using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using DocManagementBackend.Utils;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class AccountController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        public AccountController(ApplicationDbContext context) { _context = context; }

        [Authorize]
        [HttpGet("user-info")]
        public async Task<IActionResult> GetUserInfo()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userIdClaim))
                return Unauthorized("User ID claim is missing.");
            if (!int.TryParse(userIdClaim, out var userId))
                return BadRequest("Invalid user ID.");

            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return NotFound("User not found.");
            if (!user.IsActive)
                return Unauthorized("This account is desactivated!");
            var picture = string.Empty;
            if (!string.IsNullOrEmpty(user.ProfilePicture))
                {picture = $"{Request.Scheme}://{Request.Host}{user.ProfilePicture}";}
            var userInfo = new {userId = user.Id,
                username = user.Username, email = user.Email,
                role = user.Role?.RoleName ?? "SimpleUser",
                firstName = user.FirstName, lastName = user.LastName,
                profilePicture = picture, isActive = user.IsActive,
                address = user.Address, city = user.City, country = user.Country,
                phoneNumber = user.PhoneNumber, isOnline = user.IsOnline, //isBlocked = user.IsBlocked,
            };

            return Ok(userInfo);
        }

        [Authorize]
        [HttpGet("user-role")]
        public async Task<IActionResult> GetUserRole()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userIdClaim))
                return Unauthorized("User ID claim is missing.");
            if (!int.TryParse(userIdClaim, out var userId))
                return BadRequest("Invalid user ID.");
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return NotFound("User not found.");
            if (!user.IsActive)
                return Unauthorized("This account is desactivated!");
            var userRole = new { role = user.Role?.RoleName ?? "SimpleUser" };

            return Ok(userRole);
        }

        [HttpPost("forgot-password")]
        public async Task<IActionResult> ForgotPassword([FromBody] ForgotPasswordRequest request)
        {
            string? frontDomain = Environment.GetEnvironmentVariable("FRONTEND_DOMAIN");
            var user = await _context.Users.FirstOrDefaultAsync(u => u.Email == request.Email);
            if (user == null)
                return NotFound("No user found with that email address.");
            if (!user.IsEmailConfirmed)
                return Unauthorized("Email Not Verified!");
            if (!user.IsActive)
                return Unauthorized("User Account Desactivated!");
            var verificationLink = $"{frontDomain}/update-password/{user.Email}";
            var emailBody = AuthHelper.createPassEmailBody(verificationLink);
            AuthHelper.SendEmail(user.Email, "Password Reset", emailBody);
            return Ok("A Link Is Sent To Your Email.");
        }

        [HttpPut("update-password")]
        public async Task<IActionResult> UpdatePassword([FromBody] ForgotPasswordRequest request)
        {
            var user = await _context.Users.FirstOrDefaultAsync(u => u.Email == request.Email);
            if (user == null)
                return NotFound("No user found with that email address.");
            if (!user.IsEmailConfirmed)
                return Unauthorized("Email Not Verified!");
            if (!user.IsActive)
                return Unauthorized("User Account Desactivated!");
            if (!AuthHelper.IsValidPassword(request.NewPassword))
                return BadRequest("Password must be at least 8 characters long and include an uppercase letter, a lowercase letter, a digit, and a special character.");
            user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(request.NewPassword);
            await _context.SaveChangesAsync();
            return Ok("Your password is updated successfully!");
        }

        [HttpPost("resend-code")]
        public async Task<IActionResult> ResendCode([FromBody] ForgotPasswordRequest request) {
            string? frontDomain = Environment.GetEnvironmentVariable("FRONTEND_DOMAIN");
            if (string.IsNullOrEmpty(request.Email))
                return BadRequest("Email is required!");
            var user = await _context.Users.FirstOrDefaultAsync(u => u.Email == request.Email);
            if (user == null)
                return NotFound("No user found with that email address.");
            if (user.IsEmailConfirmed)
                return BadRequest("Email already verified!");
            var verifCode = new Random().Next(100000, 999999).ToString();
            // if (string.IsNullOrEmpty(user.EmailVerificationCode))
            user.EmailVerificationCode = verifCode;
            var verificationLink = $"{frontDomain}/verify/{user.Email}";
            string emailBody = AuthHelper.CreateEmailBody(verificationLink, user.EmailVerificationCode);
            AuthHelper.SendEmail(user.Email, "Email Verification", emailBody);
            await _context.SaveChangesAsync();
            return Ok("A Verification Code Is reSent To Your Email.");
        }

        [Authorize]
        [HttpPut("update-profile")]
        public async Task<IActionResult> UpdateProfile([FromBody] UpdateProfileRequest request)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userIdClaim))
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.FindAsync(userId);
            if (user == null)
                return NotFound("User not found.");
            if (!string.IsNullOrEmpty(request.Username) && user.Username != request.Username)
            {
                var userName = await _context.Users.AnyAsync(u => u.Username == request.Username);
                if (userName)
                    return BadRequest("Username is already in use.");
            }
            user.Username = request.Username ?? user.Username;
            user.FirstName = request.FirstName ?? user.FirstName;
            user.Address = request.Address ?? user.Address;
            user.City = request.City ?? user.City;
            user.Country = request.Country ?? user.Country;
            user.PhoneNumber = request.PhoneNumber ?? user.PhoneNumber;
            user.LastName = request.LastName ?? user.LastName;
            if (!string.IsNullOrEmpty(request.NewPassword))
            {
                if (!string.IsNullOrEmpty(request.CurrentPassword))
                    {if (!BCrypt.Net.BCrypt.Verify(request.CurrentPassword, user.PasswordHash))
                        return BadRequest("Current password is incorrect.");}
                else { return BadRequest("Current password is required."); }
                if (!AuthHelper.IsValidPassword(request.NewPassword))
                    return BadRequest("New password does not meet complexity requirements.");
                user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(request.NewPassword);
            }
            await _context.SaveChangesAsync();
            var logEntry = new LogHistory
            {
                UserId = userId,
                User = user,
                Timestamp = DateTime.UtcNow,
                ActionType = 3,
                Description = $"{user.Username} has updated their profile"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();
            return Ok("Profile updated successfully.");
        }

        [HttpPost("upload-image")]
        public async Task<IActionResult> UploadProfileImage(IFormFile file)
        {
            try {
                var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                if (string.IsNullOrEmpty(userIdClaim))
                    return Unauthorized("User ID claim is missing.");
                if (!int.TryParse(userIdClaim, out int userId))
                    return BadRequest("Invalid user ID format.");
                var user = await _context.Users.FindAsync(userId);
                if (user == null)
                    return NotFound("User not found.");
                if (file == null || file.Length == 0)
                    return BadRequest("No file uploaded.");
                var uploadPath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", "images", "profile");
                if (!Directory.Exists(uploadPath))
                    Directory.CreateDirectory(uploadPath);
                var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".gif" };
                var fileExtension = Path.GetExtension(file.FileName).ToLower();
                if (!allowedExtensions.Contains(fileExtension))
                    return BadRequest("Invalid file type. Allowed: JPG, JPEG, PNG, GIF");
                if (file.Length > 5 * 1024 * 1024)
                    return BadRequest("File size exceeds 5MB limit");
                if (!string.IsNullOrEmpty(user.ProfilePicture) && user.ProfilePicture != "/images/profile/default.png") {
                    var oldPath = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", user.ProfilePicture.TrimStart('/'));
                    if (System.IO.File.Exists(oldPath))
                        System.IO.File.Delete(oldPath);}
                var sanitizedUsername = string.Join("", user.Username.Split(Path.GetInvalidFileNameChars()));
                var fileName = $"{sanitizedUsername}_{Guid.NewGuid()}{fileExtension}";
                var filePath = Path.Combine(uploadPath, fileName);
                using (var stream = new FileStream(filePath, FileMode.Create))
                    await file.CopyToAsync(stream);
                user.ProfilePicture = $"/images/profile/{fileName}";
                await _context.SaveChangesAsync();
                var baseUrl = $"{Request.Scheme}://{Request.Host}";
                return Ok(new {filePath = $"{baseUrl}{user.ProfilePicture}",
                    message = "Image uploaded successfully"});
            }
            catch (Exception ex) {return StatusCode(500, $"Internal server error: {ex.Message}");}
        }

        [HttpGet("profile-image/{userId}")]
        public async Task<IActionResult> GetProfileImage(int userId)
        {
            var user = await _context.Users.FindAsync(userId);
            if (user == null || string.IsNullOrEmpty(user.ProfilePicture))
                return NotFound("Profile image not found.");
            return Ok(new { ProfilePicture = user.ProfilePicture });
        }

        [Authorize]
        [HttpPut("update-email")]
        public async Task<IActionResult> UpdateEmail([FromBody] UpdateEmailRequest request) {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userIdClaim))
                return Unauthorized("User ID claim is missing.");
            if (!int.TryParse(userIdClaim, out int userId))
                return BadRequest("Invalid user ID format.");
            var user = await _context.Users.FindAsync(userId);
            if (user == null)
                return NotFound("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is desactivated!");
            if (string.IsNullOrEmpty(request.Email))
                return BadRequest("Email is required!");
            if (await _context.Users.AnyAsync(u => u.Email == request.Email))
                return BadRequest("Email already in use!");
            user.Email = request.Email;
            user.EmailVerificationCode = new Random().Next(100000, 999999).ToString();
            user.IsActive = false;
            user.IsEmailConfirmed = false;
            string? frontDomain = Environment.GetEnvironmentVariable("FRONTEND_DOMAIN");
            var verificationLink = $"{frontDomain}/verify/{user.Email}";
            string emailBody = AuthHelper.CreateEmailBody(verificationLink, user.EmailVerificationCode);
            await _context.SaveChangesAsync();
            AuthHelper.SendEmail(user.Email, "Email Verification", emailBody);
            var logEntry = new LogHistory
            {
                UserId = userId,
                User = user,
                Timestamp = DateTime.UtcNow,
                ActionType = 3,
                Description = $"{user.Username} has updated their profile"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();
            return Ok("Email is updated successfully. Please check your email for confirmation!");
        }
    }
}
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class ActionController : ControllerBase
    {
        private readonly ApplicationDbContext _context;

        public ActionController(ApplicationDbContext context)
        {
            _context = context;
        }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<ActionDto>>> GetActions()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var actions = await _context.Actions
                .OrderBy(a => a.Title)
                .Select(a => new ActionDto
                {
                    ActionId = a.Id,
                    ActionKey = a.ActionKey,
                    Title = a.Title,
                    Description = a.Description ?? string.Empty
                })
                .ToListAsync();

            return Ok(actions);
        }

        [HttpPost]
        [Authorize(Roles = "Admin,FullUser")]
        public async Task<ActionResult<ActionDto>> CreateAction([FromBody] CreateActionDto createActionDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to create actions.");

            var action = new Models.Action
            {
                Title = createActionDto.Title,
                Description = createActionDto.Description,
                ActionKey = $"ACT-{Guid.NewGuid().ToString().Substring(0, 8)}"
            };

            _context.Actions.Add(action);
            await _context.SaveChangesAsync();

            return CreatedAtAction(nameof(GetAction), new { id = action.Id }, new ActionDto
            {
                ActionId = action.Id,
                ActionKey = action.ActionKey,
                Title = action.Title,
                Description = action.Description
            });
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<ActionDto>> GetAction(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var action = await _context.Actions.FindAsync(id);
            if (action == null)
                return NotFound("Action not found.");

            return Ok(new ActionDto
            {
                ActionId = action.Id,
                ActionKey = action.ActionKey,
                Title = action.Title,
                Description = action.Description ?? string.Empty // Provide default if null
            });
        }

        [HttpPost("assign-to-step")]
        public async Task<IActionResult> AssignActionToStep([FromBody] AssignActionToStepDto assignDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to assign actions to steps.");

            var step = await _context.StepActions.FindAsync(assignDto.StepId);
            if (step == null)
                return NotFound("Step not found.");

            var action = await _context.Actions.FindAsync(assignDto.ActionId);
            if (action == null)
                return NotFound("Action not found.");

            // Check if already assigned
            var existing = await _context.StepActions
                .FirstOrDefaultAsync(sa => sa.StepId == assignDto.StepId && sa.ActionId == assignDto.ActionId);

            if (existing != null)
                return BadRequest("Action already assigned to this step.");

            var stepAction = new StepAction
            {
                StepId = assignDto.StepId,
                ActionId = assignDto.ActionId
            };

            _context.StepActions.Add(stepAction);
            await _context.SaveChangesAsync();

            // Now add status effects for this action if provided
            if (assignDto.StatusEffects != null && assignDto.StatusEffects.Any())
            {
                foreach (var effect in assignDto.StatusEffects)
                {
                    var status = await _context.Status.FindAsync(effect.StatusId);
                    if (status != null && status.StepId == assignDto.StepId)
                    {
                        var actionStatusEffect = new ActionStatusEffect
                        {
                            ActionId = assignDto.ActionId,
                            StepId = assignDto.StepId,
                            StatusId = effect.StatusId,
                            SetsComplete = effect.SetsComplete
                        };
                        _context.ActionStatusEffects.Add(actionStatusEffect);
                    }
                }
                await _context.SaveChangesAsync();
            }

            return Ok("Action assigned to step successfully.");
        }
    }
}using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using System.Security.Claims;
using DocManagementBackend.Mappings;
using DocManagementBackend.Utils;

namespace DocManagementBackend.Controllers {
    [Authorize(Roles = "Admin")]
    [Route("api/[controller]")]
    [ApiController]
    public class AdminController : ControllerBase {
        private readonly ApplicationDbContext _context;
        public AdminController(ApplicationDbContext context) {_context = context;}

        [HttpGet("users")]
        public async Task<IActionResult> GetAllUsers() {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            var users = await _context.Users
                .Include(u => u.Role).Where(u => u.Id != userId).Select(UserMappings.ToUserDto).ToListAsync();
            return Ok(users);
        }

        [HttpGet("users/{id}")]
        public async Task<IActionResult> GetUser(int id) {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == id);
            if (user == null)
                return NotFound("User not found.");
            return Ok(user);
        }

        [HttpPost("users")]
        public async Task<IActionResult> CreateUser([FromBody] AdminCreateUserRequest request) {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            if (await _context.Users.AnyAsync(u => u.Email == request.Email))
                return BadRequest("Email is already in use.");
            if (await _context.Users.AnyAsync(u => u.Username == request.Username))
                return BadRequest("Username is already in use.");
            int roleId = 0;
            if (request.RoleName == "Admin") {roleId = 1;}
            if (request.RoleName == "SimpleUser") {roleId = 2;}
            if (request.RoleName == "FullUser") {roleId = 3;}
            var role = await _context.Roles.FindAsync(roleId);
            if (role == null)
                return BadRequest("Invalid RoleName.");
            string hashedPassword = BCrypt.Net.BCrypt.HashPassword(request.PasswordHash);
            var emailVerificationCode = new Random().Next(100000, 999999).ToString();
            var newUser = new User {Email = request.Email,
                Username = request.Username, PasswordHash = hashedPassword,
                FirstName = request.FirstName, LastName = request.LastName,
                IsEmailConfirmed = false, IsActive = false,
                CreatedAt = DateTime.UtcNow, RoleId = roleId,
                EmailVerificationCode = emailVerificationCode,
                ProfilePicture = "/images/profile/default.png"
            };
            string? frontDomain = Environment.GetEnvironmentVariable("FRONTEND_DOMAIN");
            var verificationLink = $"{frontDomain}/verify/{newUser.Email}";
            string emailBody = AuthHelper.CreateEmailBody(verificationLink, newUser.EmailVerificationCode);
            _context.Users.Add(newUser);
            await _context.SaveChangesAsync();
            AuthHelper.SendEmail(newUser.Email, "Email Verification", emailBody);
            var logEntry = new LogHistory
            {
                UserId = userId,
                User = ThisUser,
                Timestamp = DateTime.UtcNow,
                ActionType = 7,
                Description = $"{ThisUser.Username} has created a profile for {newUser.Username}"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();
            return CreatedAtAction(nameof(GetUser), new { id = newUser.Id }, new {
                newUser.Id, newUser.Username,
                newUser.Email, newUser.FirstName,
                newUser.LastName, Role = role.RoleName,
                newUser.IsActive, newUser.CreatedAt});
        }

        [HttpPut("users/{id}")]
        public async Task<IActionResult> UpdateUser(int id, [FromBody] AdminUpdateUserRequest request) {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            var user = await _context.Users.FindAsync(id);
            if (user == null)
                return NotFound("User not found.");
            if (!string.IsNullOrEmpty(request.Username) && await _context.Users.AnyAsync(u => u.Username == request.Username) && user.Username != request.Username)
                return BadRequest("Username is already in use.");
            if (!string.IsNullOrEmpty(request.Username))
                user.Username = request.Username;
            if (!string.IsNullOrEmpty(request.PasswordHash)) {
                if (!AuthHelper.IsValidPassword(request.PasswordHash))
                    return BadRequest("Password must be at least 8 characters long and include an uppercase letter, a lowercase letter, a digit, and a special character.");
                user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(request.PasswordHash);
            }
            if (!string.IsNullOrEmpty(request.FirstName))
                user.FirstName = request.FirstName;
            if (!string.IsNullOrEmpty(request.LastName))
                user.LastName = request.LastName;
            if (request.IsEmailConfirmed.HasValue)
                user.IsEmailConfirmed = request.IsEmailConfirmed.Value;
            if (request.IsActive.HasValue)
                user.IsActive = request.IsActive.Value;
            if (!string.IsNullOrEmpty(request.RoleName)) {
                int roleId = 0;
                if (request.RoleName == "Admin") {roleId = 1;}
                if (request.RoleName == "SimpleUser") {roleId = 2;}
                if (request.RoleName == "FullUser") {roleId = 3;}
                var role = await _context.Roles.FindAsync(roleId);
                if (role == null)
                    return BadRequest("Invalid RoleName.");
                user.RoleId = role.Id; user.Role = role;
            }
            await _context.SaveChangesAsync();
            var logEntry = new LogHistory
            {
                UserId = userId,
                User = ThisUser,
                Timestamp = DateTime.UtcNow,
                ActionType = 8,
                Description = $"{ThisUser.Username} has updated {user.Username}'s profile"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();
            return Ok("User updated successfully.");
        }

        [HttpPut("users/email/{id}")]
        public async Task<IActionResult> UpdateEmailUser(int id, [FromBody] AdminUpdateUserRequest request) {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            var user = await _context.Users.FindAsync(id);
            if (user == null)
                return NotFound("User not found.");
            if (!string.IsNullOrEmpty(request.Email) && await _context.Users.AnyAsync(u => u.Email == request.Email) && user.Email != request.Email)
                return BadRequest("Email is already in use.");
            if (!string.IsNullOrEmpty(request.Email))
                user.Email = request.Email;
            user.EmailVerificationCode = new Random().Next(100000, 999999).ToString();
            user.IsActive = false;
            user.IsEmailConfirmed = false;
            string? frontDomain = Environment.GetEnvironmentVariable("FRONTEND_DOMAIN");
            var verificationLink = $"{frontDomain}/verify/{user.Email}";
            string emailBody = AuthHelper.CreateEmailBody(verificationLink, user.EmailVerificationCode);
            await _context.SaveChangesAsync();
            AuthHelper.SendEmail(user.Email, "Email Verification", emailBody);
            var logEntry = new LogHistory
            {
                UserId = userId,
                User = ThisUser,
                Timestamp = DateTime.UtcNow,
                ActionType = 8,
                Description = $"{ThisUser.Username} has updated {user.Username}'s profile"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();
            return Ok($"{user.Username}'s email is updated successfully. He need to check his email for confirmation!");
        }

        [HttpDelete("users/{id}")]
        public async Task<IActionResult> DeleteUser(int id) {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            var user = await _context.Users.FindAsync(id);
            if (user == null)
                return NotFound("User not found.");
            _context.Users.Remove(user);
            await _context.SaveChangesAsync();
            var logEntry = new LogHistory
            {
                UserId = userId,
                User = ThisUser,
                Timestamp = DateTime.UtcNow,
                ActionType = 9,
                Description = $"{ThisUser.Username} has deleted {user.Username}'s profile"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();
            return Ok("User deleted successfully.");
        }

        [HttpDelete("delete-users")]
        public async Task<IActionResult> DeleteUsers([FromBody] List<int> userIds)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            if (userIds == null || !userIds.Any())
                return BadRequest("No user IDs provided.");
            var usersToDelete = await _context.Users.Where(u => userIds.Contains(u.Id)).ToListAsync();
            if (!usersToDelete.Any())
                return NotFound("No users found with the provided IDs.");
            int currentUserId = int.Parse(userIdClaim);
            usersToDelete.RemoveAll(u => u.Id == currentUserId);
            _context.Users.RemoveRange(usersToDelete);
            await _context.SaveChangesAsync();
            return Ok($"{usersToDelete.Count} Users Deleted Successfully.");
        }

        [HttpGet("logs/{id}")]
        public async Task<IActionResult> GetUserLogHistory(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin")
                return Unauthorized("User Not Allowed To do this action.");
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == id);
            if (user == null)
                return NotFound("User not found!");
            var logsDto = await _context.LogHistories.Where(l => l.UserId == id).Include(l => l.User)
                .ThenInclude(u => u.Role)
            .Select(l => new LogHistoryDto
            {
                Id = l.Id,
                ActionType = l.ActionType,
                Timestamp = l.Timestamp,
                Description = l.Description,
                User = new UserLogDto
                {
                    Username = l.User.Username,
                    Role = l.User.Role != null ? l.User.Role.RoleName : string.Empty
                }
            }).OrderByDescending(l => l.Timestamp).ToListAsync();
            if (logsDto == null)
                return NotFound("User logs not found!");
            return Ok(logsDto);
        }
    }
}
// Console.ForegroundColor = ConsoleColor.Green;
// Console.WriteLine($"=== request Users === {request.RoleName}");
// Console.ResetColor();
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using DocManagementBackend.Utils;
using Microsoft.AspNetCore.Authorization;

namespace DocManagementBackend.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class AuthController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        private readonly IConfiguration _config;
        public AuthController(ApplicationDbContext context, IConfiguration config)
        {
            _context = context; _config = config;
        }

        [HttpPost("valide-email")]
        public async Task<IActionResult> ValideEmail([FromBody] ValideUsernameRequest request)
        {
            if (await _context.Users.AnyAsync(u => u.Email == request.Email))
                return Ok("False");
            return Ok("True");
        }

        [HttpPost("valide-username")]
        public async Task<IActionResult> ValideUsername([FromBody] ValideUsernameRequest request)
        {
            if (await _context.Users.AnyAsync(u => u.Username == request.Username))
                return Ok("False");
            return Ok("True");
        }

        [HttpPost("register")]
        public async Task<IActionResult> Register([FromBody] User user)
        {
            using var transaction = await _context.Database.BeginTransactionAsync();
            var existingUser = await _context.Users.AnyAsync(u => u.Email == user.Email);
            if (existingUser)
                return BadRequest("Email is already in use.");
            var existingUsername = await _context.Users.AnyAsync(u => u.Username == user.Username);
            if (existingUsername)
                return BadRequest("Username is already in use.");
            if (!AuthHelper.IsValidPassword(user.PasswordHash))
                return BadRequest("Password must be at least 8 characters long and include an uppercase letter, a lowercase letter, a digit, and a special character.");
            var adminSecretHeader = Request.Headers["AdminSecret"].FirstOrDefault();
            if (!string.IsNullOrEmpty(adminSecretHeader))
            {
                var expectedAdminSecret = Environment.GetEnvironmentVariable("ADMIN_SECRET");
                if (adminSecretHeader == expectedAdminSecret)
                {
                    var adminRole = await _context.Roles.FirstOrDefaultAsync(r => r.RoleName == "Admin");
                    if (adminRole != null)
                        {user.RoleId = adminRole.Id; user.Role = adminRole;}
                }
                else
                    return Unauthorized("Invalid admin secret.");
            }
            else
            {
                var simpleUserRole = await _context.Roles.FirstOrDefaultAsync(r => r.RoleName == "SimpleUser");
                if (simpleUserRole != null)
                    {user.RoleId = simpleUserRole.Id; user.Role = simpleUserRole;}
                else
                    return BadRequest("Default role not found.");
            }
            user.EmailVerificationCode = new Random().Next(100000, 999999).ToString();
            user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(user.PasswordHash);
            user.IsActive = false;
            user.IsEmailConfirmed = false;
            user.ProfilePicture = "/images/profile/default.png";
            string? frontDomain = Environment.GetEnvironmentVariable("FRONTEND_DOMAIN");
            var verificationLink = $"{frontDomain}/verify/{user.Email}";
            string emailBody = AuthHelper.CreateEmailBody(verificationLink, user.EmailVerificationCode);
            try
            {
                _context.Users.Add(user);
                var logEntry = new LogHistory
                {
                    UserId = user.Id,
                    User = user,
                    Timestamp = DateTime.UtcNow,
                    ActionType = 2,
                    Description = $"{user.Username} has created their profile"
                };
                _context.LogHistories.Add(logEntry);
                await _context.SaveChangesAsync();
                await transaction.CommitAsync();
                AuthHelper.SendEmail(user.Email, "Email Verification", emailBody);
                return Ok("Registration successful! Please check your email for the verification code.");
            }
            catch (Exception ex)
            {
                await transaction.RollbackAsync();
                return StatusCode(500, $"An error occurred. Please try again. {ex.Message}");
            }
        }

        [HttpPost("verify-email")]
        public async Task<IActionResult> VerifyEmail([FromBody] VerifyEmailRequest request)
        {
            var user = await _context.Users.FirstOrDefaultAsync(u => u.Email == request.Email);
            if (user == null)
                return NotFound("User not found.");
            if (user.IsEmailConfirmed && user.EmailVerificationCode == null)
                return BadRequest("Email is already verified !");
            if (user.EmailVerificationCode != request.VerificationCode)
                return BadRequest("Invalid verification code.");
            user.IsEmailConfirmed = true;
            user.IsActive = true;
            // user.IsOnline = false;
            user.EmailVerificationCode = null;
            await _context.SaveChangesAsync();

            return Ok("Email verified successfully!");
        }

        [HttpPost("clear-users")]
        public async Task<IActionResult> ClearUsers()
        {
            var users = _context.Users.Where(u => u.Email != null).ToList();
            _context.Users.RemoveRange(users);
            await _context.SaveChangesAsync();
            return Ok("All users with emails have been deleted.");
        }

        [HttpPost("clear-users/{id}")]
        public async Task<IActionResult> ClearUser(int id)
        {
            var user = _context.Users.Where(u => u.Id == id).ToList();
            _context.Users.RemoveRange(user);
            await _context.SaveChangesAsync();
            return Ok("the user have been deleted.");
        }

        [HttpPost("login")]
        public async Task<IActionResult> Login([FromBody] LoginRequest model)
        {
            if (string.IsNullOrEmpty(model.EmailOrUsername))
                return BadRequest("Email or Username is required.");
            if (string.IsNullOrEmpty(model.Password))
                return BadRequest("Password is required.");
            var user = await _context.Users
                .Include(u => u.Role)
                .FirstOrDefaultAsync(u => u.Email == model.EmailOrUsername || u.Username == model.EmailOrUsername);
            if (user == null) {return Unauthorized("Invalid email or username.");}
            if (!BCrypt.Net.BCrypt.Verify(model.Password, user.PasswordHash))
                return Unauthorized("Invalid password.");
            if (!user.IsEmailConfirmed)
                return Unauthorized("Your account is not activated yet !! Please check your email for verification before logging in.");
            if (!user.IsActive)
                return Unauthorized("User Account Is Desactivated!");
            var accessToken = AuthHelper.GenerateAccessToken(user);
            var refreshToken = AuthHelper.GenerateRefreshToken();
            user.RefreshToken = refreshToken;
            user.RefreshTokenExpiry = DateTime.UtcNow.AddDays(7);
            user.IsOnline = true;
            var login = new LogHistory { UserId = user.Id, User = user, ActionType = 1, Description = "login", Timestamp = DateTime.UtcNow };
            _context.LogHistories.Add(login);
            await _context.SaveChangesAsync();
            var cookieOptions = new CookieOptions
            {
                HttpOnly = true,
                Secure = true,
                SameSite = SameSiteMode.None,
                Expires = DateTime.UtcNow.AddHours(3)
            };
            Response.Cookies.Append("accessToken", accessToken, cookieOptions);
            Response.Cookies.Append("refreshToken", refreshToken, cookieOptions);
            return Ok(new { accessToken, refreshToken });
        }

        [HttpPost("refresh-token")]
        public async Task<IActionResult> RefreshToken()
        {
            var refreshToken = Request.Cookies["refresh_token"];
            if (string.IsNullOrEmpty(refreshToken))
                return Unauthorized("No refresh token provided.");
            var user = await _context.Users.FirstOrDefaultAsync(u => u.RefreshToken == refreshToken);
            if (user == null || user.RefreshTokenExpiry < DateTime.UtcNow)
                return Unauthorized("Invalid or expired refresh token.");
            var newAccessToken = AuthHelper.GenerateAccessToken(user);
            var newRefreshToken = AuthHelper.GenerateRefreshToken();
            user.RefreshToken = newRefreshToken;
            user.RefreshTokenExpiry = DateTime.UtcNow.AddHours(3);
            await _context.SaveChangesAsync();
            var cookieOptions = new CookieOptions
            {
                HttpOnly = true,
                Secure = true,
                SameSite = SameSiteMode.None,
                Expires = DateTime.UtcNow.AddDays(7)
            };
            // Response.Cookies.Append("accessToken", accessToken, cookieOptions);
            Response.Cookies.Append("refreshToken", refreshToken, cookieOptions);

            return Ok(new { accessToken = newAccessToken });
        }

        [Authorize]
        [HttpPost("logout")]
        public async Task<IActionResult> Logout([FromBody] LogoutRequest request)
        {
            var user = await _context.Users.FirstOrDefaultAsync(u => u.Id == request.UserId);
            if (user == null)
                return Unauthorized("User Not Found!");
            var logEntry = new LogHistory { UserId = user.Id, User = user, Timestamp = DateTime.UtcNow, ActionType = 0, Description = "logout"};
            _context.LogHistories.Add(logEntry);
            user.RefreshToken = null;
            user.RefreshTokenExpiry = null;
            user.IsOnline = false;
            await _context.SaveChangesAsync();
            Response.Cookies.Delete("refresh_token");

            return Ok("Logged out successfully.");
        }
    }
}
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using DocManagementBackend.Services;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class CircuitController : ControllerBase
    {
        private readonly CircuitManagementService _circuitService;
        private readonly ApplicationDbContext _context;

        public CircuitController(CircuitManagementService circuitService, ApplicationDbContext context)
        {
            _circuitService = circuitService;
            _context = context;
        }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<CircuitDto>>> GetCircuits()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var circuits = await _context.Circuits
                .Include(c => c.Steps.OrderBy(cd => cd.OrderIndex))
                .ToListAsync();

            var circuitDtos = circuits.Select(c => new CircuitDto
            {
                Id = c.Id,
                CircuitKey = c.CircuitKey,
                Title = c.Title,
                Descriptif = c.Descriptif,
                IsActive = c.IsActive,
                HasOrderedFlow = c.HasOrderedFlow,
                AllowBacktrack = c.AllowBacktrack,
                Steps = c.Steps.Select(cd => new StepDto
                {
                    Id = cd.Id,
                    StepKey = cd.StepKey,
                    CircuitId = cd.CircuitId,
                    Title = cd.Title,
                    Descriptif = cd.Descriptif,
                    OrderIndex = cd.OrderIndex,
                    ResponsibleRoleId = cd.ResponsibleRoleId,
                    IsFinalStep = cd.IsFinalStep
                }).ToList()
            }).ToList();

            return Ok(circuitDtos);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<CircuitDto>> GetCircuit(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var circuit = await _context.Circuits
                .Include(c => c.Steps.OrderBy(cd => cd.OrderIndex))
                .FirstOrDefaultAsync(c => c.Id == id);

            if (circuit == null)
                return NotFound("Circuit not found.");

            var circuitDto = new CircuitDto
            {
                Id = circuit.Id,
                CircuitKey = circuit.CircuitKey,
                Title = circuit.Title,
                Descriptif = circuit.Descriptif,
                IsActive = circuit.IsActive,
                HasOrderedFlow = circuit.HasOrderedFlow,
                AllowBacktrack = circuit.AllowBacktrack,
                Steps = circuit.Steps.Select(cd => new StepDto
                {
                    Id = cd.Id,
                    StepKey = cd.StepKey,
                    CircuitId = cd.CircuitId,
                    Title = cd.Title,
                    Descriptif = cd.Descriptif,
                    OrderIndex = cd.OrderIndex,
                    ResponsibleRoleId = cd.ResponsibleRoleId,
                    IsFinalStep = cd.IsFinalStep
                }).ToList()
            };

            return Ok(circuitDto);
        }

        [HttpPost]
        public async Task<ActionResult<CircuitDto>> CreateCircuit([FromBody] CreateCircuitDto createCircuitDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to create circuits.");

            Console.WriteLine($"is active value ========> {createCircuitDto.IsActive}");

            var circuit = new Circuit
            {
                Title = createCircuitDto.Title,
                Descriptif = createCircuitDto.Descriptif,
                HasOrderedFlow = createCircuitDto.HasOrderedFlow,
                AllowBacktrack = createCircuitDto.AllowBacktrack,
                IsActive = createCircuitDto.IsActive
            };

            try
            {
                Console.WriteLine($"is active value circuit ========> {circuit.IsActive}");
                var createdCircuit = await _circuitService.CreateCircuitAsync(circuit);
                Console.WriteLine($"is active value circuit ========> {createdCircuit.IsActive}");

                return CreatedAtAction(nameof(GetCircuit), new { id = createdCircuit.Id }, new CircuitDto
                {
                    Id = createdCircuit.Id,
                    CircuitKey = createdCircuit.CircuitKey,
                    Title = createdCircuit.Title,
                    Descriptif = createdCircuit.Descriptif,
                    IsActive = createdCircuit.IsActive,
                    HasOrderedFlow = createdCircuit.HasOrderedFlow,
                    AllowBacktrack = createdCircuit.AllowBacktrack,
                    Steps = new List<StepDto>()
                });
            }
            catch (Exception ex)
            {
                return BadRequest($"Error creating circuit: {ex.Message}");
            }
        }

        [HttpPut("steps/{stepId}")]
        public async Task<IActionResult> UpdateStep(int stepId, [FromBody] UpdateStepDto updateStepDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to modify steps.");

            // Find the step to update
            var step = await _context.Steps.Include(s => s.Circuit).FirstOrDefaultAsync(s => s.Id == stepId);
            if (step == null)
                return NotFound("Step not found.");

            // Check if the step belongs to an active circuit
            if (step.Circuit != null && step.Circuit.IsActive)
                return BadRequest("Cannot update a step that belongs to an active circuit.");

            // Update step properties
            if (!string.IsNullOrEmpty(updateStepDto.Title))
                step.Title = updateStepDto.Title;

            if (!string.IsNullOrEmpty(updateStepDto.Descriptif))
                step.Descriptif = updateStepDto.Descriptif;

            // if (updateStepDto.OrderIndex > 0)
            //     step.OrderIndex = updateStepDto.OrderIndex;

            // if (updateStepDto.ResponsibleRoleId.HasValue)
            // {
            //     // Validate role ID if provided
            //     var role = await _context.Roles.FindAsync(updateStepDto.ResponsibleRoleId.Value);
            //     if (role == null)
            //         return BadRequest("Invalid role ID.");

            //     step.ResponsibleRoleId = updateStepDto.ResponsibleRoleId;
            // }

            if (updateStepDto.IsFinalStep.HasValue)
                step.IsFinalStep = updateStepDto.IsFinalStep.Value;

            try
            {
                await _context.SaveChangesAsync();
                return Ok("Step updated successfully.");
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!await _context.Steps.AnyAsync(s => s.Id == stepId))
                    return NotFound("Step no longer exists.");
                throw;
            }
        }

        [HttpPost("{circuitId}/steps")]
        public async Task<ActionResult<StepDto>> AddStepToCircuit(int circuitId, [FromBody] CreateStepDto createStepDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to modify circuits.");

            var step = new Step
            {
                CircuitId = circuitId,
                Title = createStepDto.Title,
                Descriptif = createStepDto.Descriptif,
                ResponsibleRoleId = createStepDto.ResponsibleRoleId,
                OrderIndex = createStepDto.OrderIndex
            };

            try
            {
                var createdStep = await _circuitService.AddStepToCircuitAsync(step);

                return CreatedAtAction(nameof(GetCircuit), new { id = circuitId }, new StepDto
                {
                    Id = createdStep.Id,
                    StepKey = createdStep.StepKey,
                    CircuitId = createdStep.CircuitId,
                    Title = createdStep.Title,
                    Descriptif = createdStep.Descriptif,
                    OrderIndex = createdStep.OrderIndex,
                    ResponsibleRoleId = createdStep.ResponsibleRoleId,
                    IsFinalStep = createdStep.IsFinalStep
                });
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (Exception ex)
            {
                return BadRequest($"Error adding step: {ex.Message}");
            }
        }

        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateCircuit(int id, [FromBody] CreateCircuitDto updateCircuitDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to modify circuits.");

            var circuit = await _context.Circuits.FindAsync(id);
            if (circuit == null)
                return NotFound("Circuit not found.");

            circuit.Title = updateCircuitDto.Title;
            circuit.Descriptif = updateCircuitDto.Descriptif;
            circuit.HasOrderedFlow = updateCircuitDto.HasOrderedFlow;
            circuit.AllowBacktrack = updateCircuitDto.AllowBacktrack;
            circuit.IsActive = updateCircuitDto.IsActive;

            try
            {
                await _context.SaveChangesAsync();
                return Ok("Circuit updated successfully.");
            }
            catch (Exception ex)
            {
                return BadRequest($"Error updating circuit: {ex.Message}");
            }
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteCircuit(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to delete circuits.");

            var circuit = await _context.Circuits.FindAsync(id);
            if (circuit == null)
                return NotFound("Circuit not found.");

            // Check if circuit is in use by documents
            var inUse = await _context.Documents.AnyAsync(d => d.CircuitId == id);
            if (inUse)
                return BadRequest("Cannot delete circuit that is in use by documents.");

            _context.Circuits.Remove(circuit);
            await _context.SaveChangesAsync();

            return Ok("Circuit deleted successfully.");
        }
    }
}using Microsoft.AspNetCore.Mvc;
using DocManagementBackend.Models;
using DocManagementBackend.Data;
using Microsoft.AspNetCore.Authorization;
using Microsoft.EntityFrameworkCore;
using System.Security.Claims;
using DocManagementBackend.Mappings;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class DocumentsController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        public DocumentsController(ApplicationDbContext context) { _context = context; }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<DocumentDto>>> GetDocuments()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            var documents = await _context.Documents
                .Include(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Include(d => d.DocumentType)
                .Include(d => d.SubType)
                .Include(d => d.CurrentStep)
                .Include(d => d.Lignes)
                .Select(DocumentMappings.ToDocumentDto)
                .ToListAsync();

            return Ok(documents);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<DocumentDto>> GetDocument(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            var documentDto = await _context.Documents
                .Include(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Include(d => d.DocumentType)
                .Include(d => d.SubType)
                .Include(d => d.CurrentStep)
                .Include(d => d.Lignes)
                .Where(d => d.Id == id)
                .Select(DocumentMappings.ToDocumentDto)
                .FirstOrDefaultAsync();
            if (documentDto == null) { return NotFound("Document not found!"); }

            return Ok(documentDto);
        }

        [HttpGet("recent")]
        public async Task<ActionResult<IEnumerable<DocumentDto>>> GetRecentDocuments([FromQuery] int limit = 5)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            // Ensure the limit is reasonable
            if (limit <= 0)
                limit = 5;
            if (limit > 50)
                limit = 50; // Set a maximum limit to prevent excessive queries

            var recentDocuments = await _context.Documents
                .Include(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Include(d => d.DocumentType)
                .Include(d => d.SubType)
                .Include(d => d.CurrentStep)
                .Include(d => d.Lignes)
                .OrderByDescending(d => d.CreatedAt) // Sort by creation date, newest first
                .Take(limit) // Take only the specified number of documents
                .Select(DocumentMappings.ToDocumentDto)
                .ToListAsync();

            return Ok(recentDocuments);
        }

        [HttpPost]
        public async Task<ActionResult<DocumentDto>> CreateDocument([FromBody] CreateDocumentRequest request)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return BadRequest("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action...!");

            var docType = await _context.DocumentTypes.FirstOrDefaultAsync(t => t.Id == request.TypeId);
            if (docType == null)
                return BadRequest("Invalid Document type!");

            SubType? subType = null;
            if (request.SubTypeId.HasValue)
            {
                subType = await _context.SubTypes.FirstOrDefaultAsync(s => s.Id == request.SubTypeId.Value);
                if (subType == null)
                    return BadRequest("Invalid SubType!");

                if (subType.DocumentTypeId != request.TypeId)
                    return BadRequest("Selected SubType does not belong to the selected Document Type!");

                var documentDate = request.DocDate ?? DateTime.UtcNow;
                if (documentDate < subType.StartDate || documentDate > subType.EndDate)
                    return BadRequest($"Document date ({documentDate:d}) must be within the selected SubType date range ({subType.StartDate:d} to {subType.EndDate:d})");
            }

            var docDate = request.DocDate ?? DateTime.UtcNow;
            var docAlias = "D";
            if (!string.IsNullOrEmpty(request.DocumentAlias))
                docAlias = request.DocumentAlias.ToUpper();

            docType.DocumentCounter++;
            docType.DocCounter++;
            int counterValue = docType.DocCounter;
            string paddedCounter = counterValue.ToString("D4");

            string documentKey;
            if (subType != null)
                documentKey = $"{subType.SubTypeKey}-{paddedCounter}";
            else
                documentKey = $"{docType.TypeKey}{docAlias}-{paddedCounter}";

            var document = new Document
            {
                Title = request.Title,
                DocumentAlias = docAlias,
                Content = request.Content,
                CreatedByUserId = userId,
                CreatedBy = user,
                DocDate = docDate,
                TypeId = request.TypeId,
                DocumentType = docType,
                SubTypeId = request.SubTypeId,
                SubType = subType,
                CircuitId = request.CircuitId,
                Status = 0,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow,
                DocumentKey = documentKey
            };

            _context.Documents.Add(document);
            await _context.SaveChangesAsync();

            // Now fetch the complete document with all related entities
            var createdDocument = await _context.Documents
                .Include(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Include(d => d.DocumentType)
                .Include(d => d.SubType)
                .Include(d => d.CurrentStep)
                .Where(d => d.Id == document.Id)
                .Select(DocumentMappings.ToDocumentDto)
                .FirstOrDefaultAsync();

            var logEntry = new LogHistory
            {
                UserId = userId,
                User = user,
                Timestamp = DateTime.UtcNow,
                ActionType = 4,
                Description = $"{user.Username} has created the document {document.DocumentKey}"
            };
            _context.LogHistories.Add(logEntry);
            await _context.SaveChangesAsync();

            return CreatedAtAction(nameof(GetDocument), new { id = document.Id }, createdDocument);
        }

        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateDocument(int id, [FromBody] UpdateDocumentRequest request)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return BadRequest("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action...!");
            var document = await _context.Documents.FindAsync(id);
            if (document == null)
                return NotFound("Document not found.");

            // Update basic document fields
            document.Content = request.Content ?? document.Content;
            document.Title = request.Title ?? document.Title;
            document.DocDate = request.DocDate ?? document.DocDate;

            // Handle SubType changes
            if (request.SubTypeId.HasValue && request.SubTypeId != document.SubTypeId)
            {
                var subType = await _context.SubTypes.FindAsync(request.SubTypeId.Value);
                if (subType == null)
                    return BadRequest("Invalid SubType!");

                // If type is also changing, verify SubType belongs to that type
                if (request.TypeId.HasValue && request.TypeId != document.TypeId)
                {
                    if (subType.DocumentTypeId != request.TypeId.Value)
                        return BadRequest("Selected SubType does not belong to the selected Document Type!");
                }
                else
                {
                    // Otherwise check against current document type
                    if (subType.DocumentTypeId != document.TypeId)
                        return BadRequest("Selected SubType does not belong to the document's current type!");
                }

                // Verify DocDate falls within SubType date range
                if (document.DocDate < subType.StartDate || document.DocDate > subType.EndDate)
                    return BadRequest($"Document date ({document.DocDate:d}) must be within the selected SubType date range ({subType.StartDate:d} to {subType.EndDate:d})");

                document.SubTypeId = request.SubTypeId;
                document.SubType = subType;

                // Need to update document key
                var docType = await _context.DocumentTypes.FindAsync(document.TypeId);

                // Extract counter from the existing key (assuming format ends with -XXXX)
                string counterStr = document.DocumentKey.Split('-').Last();
                string documentKey = $"{subType.SubTypeKey}-{counterStr}";
                document.DocumentKey = documentKey;
            }
            // Handle removing a subtype
            else if (request.SubTypeId.HasValue && request.SubTypeId.Value == 0 && document.SubTypeId.HasValue)
            {
                document.SubTypeId = null;
                document.SubType = null;

                // Regenerate document key using the document type
                var docType = await _context.DocumentTypes.FindAsync(document.TypeId);
                string counterStr = document.DocumentKey.Split('-').Last();
                string documentKey = $"{docType!.TypeKey}{document.DocumentAlias}-{counterStr}";
                document.DocumentKey = documentKey;
            }

            // Handle type changes as in original method
            if (request.TypeId.HasValue)
            {
                // Console.ForegroundColor = ConsoleColor.Green;
                // Console.WriteLine($"=== request TYpe === {request.TypeId}");
                // Console.ResetColor();
                if (request.TypeId != document.TypeId)
                {
                    var docType = await _context.DocumentTypes.FirstOrDefaultAsync(t => t.Id == request.TypeId);
                    if (docType == null)
                        return BadRequest("Invalid type!");
                    var type = await _context.DocumentTypes.FirstOrDefaultAsync(t => t.Id == document.TypeId);
                    if (type == null)
                        return BadRequest("Missing DocumentType");
                    type.DocumentCounter--;

                    // If changing document type, clear the subtype if it doesn't match
                    if (document.SubTypeId.HasValue)
                    {
                        var subType = await _context.SubTypes.FindAsync(document.SubTypeId.Value);
                        if (subType!.DocumentTypeId != request.TypeId)
                        {
                            document.SubTypeId = null;
                            document.SubType = null;
                        }
                    }

                    document.TypeId = request.TypeId ?? document.TypeId;
                    document.DocumentType = docType;
                    docType.DocumentCounter++;
                    int counterValue = docType.DocumentCounter;
                    string paddedCounter = counterValue.ToString("D4");

                    if (document.SubTypeId.HasValue && document.SubType != null)
                        document.DocumentKey = $"{document.SubType.SubTypeKey}-{paddedCounter}";
                    else
                        document.DocumentKey = $"{docType.TypeKey}{document.DocumentAlias.ToUpper()}-{paddedCounter}";
                }
            }

            if (!string.IsNullOrEmpty(request.DocumentAlias))
            {
                document.DocumentAlias = request.DocumentAlias.ToUpper();

                // Only update the document key if we're not using a subtype
                if (!document.SubTypeId.HasValue)
                {
                    var docType = await _context.DocumentTypes.FindAsync(document.TypeId);
                    string counterStr = document.DocumentKey.Split('-').Last();
                    document.DocumentKey = $"{docType!.TypeKey}{request.DocumentAlias.ToUpper()}-{counterStr}";
                }
            }

            if (request.CircuitId.HasValue)
            {
                var circuit = await _context.Circuits.FirstOrDefaultAsync(c => c.Id == request.CircuitId);
                if (circuit == null)
                    return BadRequest("Invalid Circuit!");
                document.CircuitId = request.CircuitId;
                document.Circuit = circuit;
            }

            document.UpdatedAt = DateTime.UtcNow;
            _context.Entry(document).State = EntityState.Modified;

            try
            {
                await _context.SaveChangesAsync();
                var logEntry = new LogHistory
                {
                    UserId = userId,
                    User = user,
                    Timestamp = DateTime.UtcNow,
                    ActionType = 5,
                    Description = $"{user.Username} has updated the document {document.DocumentKey}"
                };
                _context.LogHistories.Add(logEntry);
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!_context.Documents.Any(d => d.Id == id)) { return NotFound(); }
                else { throw; }
            }
            return Ok("Document updated!");
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteDocument(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return BadRequest("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action...!");

            // Begin a transaction to ensure all operations either succeed or fail together
            using var transaction = await _context.Database.BeginTransactionAsync();

            try
            {
                var document = await _context.Documents.FindAsync(id);
                if (document == null)
                    return NotFound("Document not found!");

                // Delete related records in DocumentCircuitHistory
                var historyRecords = await _context.DocumentCircuitHistory
                    .Where(dch => dch.DocumentId == id)
                    .ToListAsync();

                if (historyRecords.Any())
                    _context.DocumentCircuitHistory.RemoveRange(historyRecords);

                // Delete related records in DocumentStatus
                var statusRecords = await _context.DocumentStatus
                    .Where(ds => ds.DocumentId == id)
                    .ToListAsync();

                if (statusRecords.Any())
                    _context.DocumentStatus.RemoveRange(statusRecords);

                // Update the document type counter
                var type = await _context.DocumentTypes.FindAsync(document.TypeId);
                if (type == null)
                    return BadRequest("Missing DocumentType");
                if (type.DocumentCounter > 0)
                    type.DocumentCounter--;

                // Log the deletion
                var logEntry = new LogHistory
                {
                    UserId = userId,
                    User = user,
                    Timestamp = DateTime.UtcNow,
                    ActionType = 6,
                    Description = $"{user.Username} has deleted the document {document.DocumentKey}"
                };
                _context.LogHistories.Add(logEntry);

                // Delete the document
                _context.Documents.Remove(document);
                await _context.SaveChangesAsync();

                // Commit the transaction
                await transaction.CommitAsync();

                return Ok("Document deleted!");
            }
            catch (Exception ex)
            {
                // Roll back the transaction on error
                await transaction.RollbackAsync();
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpGet("Types")]
        public async Task<ActionResult> GetTypes()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID or Role claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return BadRequest("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action...!");
            var types = await _context.DocumentTypes.ToListAsync();
            return Ok(types);
        }

        [HttpPost("valide-typeKey")]
        public async Task<IActionResult> ValideTypeKey([FromBody] DocumentTypeDto request)
        {
            if (await _context.DocumentTypes.AnyAsync(t => t.TypeKey == request.TypeKey))
                return Ok("False");
            return Ok("True");
        }

        [HttpPost("Types")]
        public async Task<ActionResult> CreateTypes([FromBody] DocumentTypeDto request)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return BadRequest("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to do this action.");
            if (string.IsNullOrEmpty(request.TypeName))
                return BadRequest("Type Name is required!");
            var typeNameExists = await _context.DocumentTypes.AnyAsync(t => t.TypeName == request.TypeName);
            if (typeNameExists)
                return BadRequest("Type Name already exists!");
            var typeCounter = await _context.TypeCounter.FirstOrDefaultAsync();
            if (typeCounter == null)
            {
                typeCounter = new TypeCounter { Counter = 1 };
                _context.TypeCounter.Add(typeCounter);
            }
            string baseKey = (request.TypeName.Length >= 2) ? request.TypeName.Substring(0, 2).ToUpper() : request.TypeName.ToUpper();
            if (!string.IsNullOrEmpty(request.TypeKey))
                baseKey = request.TypeKey;
            bool exists = await _context.DocumentTypes.AnyAsync(t => t.TypeKey == baseKey);
            string finalTypeKey = exists ? $"{baseKey}{typeCounter.Counter++}" : baseKey;
            var type = new DocumentType
            {
                TypeKey = finalTypeKey,
                TypeName = request.TypeName,
                TypeAttr = request.TypeAttr,
                DocumentCounter = 0,
                DocCounter = 0
            };
            _context.DocumentTypes.Add(type);
            await _context.SaveChangesAsync();
            return Ok("Type successfully added!");
        }

        [HttpPost("valide-type")]
        public async Task<IActionResult> ValideType([FromBody] DocumentTypeDto request)
        {
            var typeName = request.TypeName.ToLower();
            var type = await _context.DocumentTypes.AnyAsync(t => t.TypeName.ToLower() == typeName);
            if (type)
                return Ok("True");
            return Ok("False");
        }

        [HttpPut("Types/{id}")]
        public async Task<IActionResult> UpdateType([FromBody] DocumentTypeDto request, int id)
        {
            var ThisType = await _context.DocumentTypes.FindAsync(id);
            if (ThisType == null)
                return NotFound("No type with this id!");
            if (string.IsNullOrEmpty(request.TypeName))
            {
                var typeName = request.TypeName.ToLower();
                var type = await _context.DocumentTypes.FirstOrDefaultAsync(t => t.TypeName.ToLower() == typeName);
                if (type != null)
                    if (type.Id != ThisType.Id)
                        return BadRequest("TypeName already exist");
                ThisType.TypeName = request.TypeName;
            }
            if (string.IsNullOrEmpty(request.TypeAttr))
                ThisType.TypeAttr = request.TypeAttr;
            return Ok("Type edited successfully");
        }

        [HttpDelete("Types/{id}")]
        public async Task<IActionResult> DeleteType(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (user == null)
                return BadRequest("User not found.");
            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action...!");
            var type = await _context.DocumentTypes.FindAsync(id);
            if (type == null)
                return NotFound("No type with this id!");
            if (type.DocumentCounter > 0)
                return BadRequest("This type can't be deleted. There are documents registered with!");
            _context.DocumentTypes.Remove(type);
            await _context.SaveChangesAsync();

            return Ok("Type deleted!");
        }
    }
}
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using DocManagementBackend.Mappings;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class LignesController : ControllerBase
    {
        private readonly ApplicationDbContext _context;

        public LignesController(ApplicationDbContext context) { _context = context; }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<LigneDto>>> GetLignes() {
            var lignes = await _context.Lignes
                .Include(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(LigneMappings.ToLigneDto).ToListAsync();
            return Ok(lignes);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<LigneDto>> GetLigne(int id) {
            var ligneDto = await _context.Lignes
                .Include(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Where(l => l.Id == id).Select(LigneMappings.ToLigneDto).FirstOrDefaultAsync();
            if (ligneDto == null)
                return NotFound("Ligne not found.");
            return Ok(ligneDto);
        }

        [HttpGet("by-document/{documentId}")]
        public async Task<ActionResult<IEnumerable<LigneDto>>> GetLignesByDocumentId(int documentId) {
            var lignes = await _context.Lignes
                .Where(l => l.DocumentId == documentId)
                .Include(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(LigneMappings.ToLigneDto).ToListAsync();
            return Ok(lignes);
        }

        [HttpPost]
        public async Task<ActionResult<LigneDto>> CreateLigne([FromBody] Ligne ligne) {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin" && ThisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action.");
            var document = await _context.Documents.FindAsync(ligne.DocumentId);
            if (document == null)
                return BadRequest("Invalid DocumentId. Document not found.");
            ligne.CreatedAt = DateTime.UtcNow;
            ligne.UpdatedAt = DateTime.UtcNow;
            ligne.LigneKey = $"{document.DocumentKey}L{document.LigneCouter++}";
            _context.Lignes.Add(ligne);
            await _context.SaveChangesAsync();
            var ligneDto = await _context.Lignes
                .Include(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Where(l => l.Id == ligne.Id).Select(LigneMappings.ToLigneDto).FirstOrDefaultAsync();
            return CreatedAtAction(nameof(GetLigne), new { id = ligne.Id }, ligneDto);
        }


        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateLigne(int id, [FromBody] Ligne updatedLigne) {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin" && ThisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action.");
            var ligne = await _context.Lignes.FindAsync(id);
            if (ligne == null)
                return NotFound("Ligne not found.");
            if (!string.IsNullOrEmpty(updatedLigne.Title))
                ligne.Title = updatedLigne.Title;
            if (!string.IsNullOrEmpty(updatedLigne.Article))
                ligne.Article = updatedLigne.Article;
            if (updatedLigne.Prix >= 0)
                ligne.Prix = updatedLigne.Prix;
            ligne.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();
            return Ok("Ligne updated!");
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteLigne(int id) {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin" && ThisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action.");
            var ligne = await _context.Lignes.FindAsync(id);
            if (ligne == null)
                return NotFound("Ligne not found.");
            _context.Lignes.Remove(ligne);
            await _context.SaveChangesAsync();
            return Ok("Ligne deleted!");
        }
    }
}
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using Google.Apis.Auth;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace DocManagementBackend.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class OAuthController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        private readonly IConfiguration _config;
        public OAuthController(ApplicationDbContext context, IConfiguration config){ _context = context; _config = config;}

        [HttpPost("google-login")]
        public async Task<IActionResult> GoogleLogin([FromBody] GoogleLoginRequest request) {
            try {
                var payload = await GoogleJsonWebSignature.ValidateAsync(request.IdToken);
                var user = await _context.Users.Include(u => u.Role)
                                  .FirstOrDefaultAsync(u => u.Email == payload.Email);
                if (user == null) {
                    user = new User {
                        Email = payload.Email,
                        Username = payload.Email.Split('@')[0],
                        FirstName = payload.GivenName, LastName = payload.FamilyName,
                        IsEmailConfirmed = true, IsActive = true, CreatedAt = DateTime.UtcNow,
                        PasswordHash = BCrypt.Net.BCrypt.HashPassword(Guid.NewGuid().ToString())};
                    var simpleUserRole = await _context.Roles.FirstOrDefaultAsync(r => r.RoleName == "SimpleUser");
                    if (simpleUserRole != null) {
                        user.RoleId = simpleUserRole.Id;
                        user.Role = simpleUserRole;}

                    _context.Users.Add(user);
                    await _context.SaveChangesAsync();
                }
                var accessToken = GenerateAccessToken(user);
                return Ok(new { accessToken });
            }
            catch (Exception ex) {
                return Unauthorized($"Invalid Google token: {ex.Message}");}
        }

        private string GenerateAccessToken(User user) {
            var secretKey = Environment.GetEnvironmentVariable("JWT_SECRET");;
            if (string.IsNullOrEmpty(secretKey))
                throw new InvalidOperationException("JWT configuration is missing.");

            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey));
            var claims = new[] {new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
                new Claim(JwtRegisteredClaimNames.Email, user.Email),
                new Claim("Username", user.Username),
                new Claim("IsActive", user.IsActive.ToString()),
                new Claim(ClaimTypes.Role, user.Role?.RoleName ?? "SimpleUser")};

            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
            var expMinutes = Environment.GetEnvironmentVariable("ExpiryMinutes");
            if (string.IsNullOrEmpty(expMinutes))
                throw new InvalidOperationException("ExpiryMinutes is missing.");

            var token = new JwtSecurityToken(issuer: Environment.GetEnvironmentVariable("ISSUER"),
                audience: Environment.GetEnvironmentVariable("AUDIENCE"), claims: claims,
                expires: DateTime.UtcNow.AddMinutes(int.Parse(expMinutes)),
                signingCredentials: creds);

            return new JwtSecurityTokenHandler().WriteToken(token);
        }
    }
}// using Microsoft.AspNetCore.Mvc;
// using System.Threading.Tasks;
// using DocManagementBackend.Services;
// using DocManagementBackend.Models;
// using DocManagementBackend.Data;
// using Microsoft.EntityFrameworkCore;

// namespace DocManagementBackend.Controllers
// {
//     [Route("api/[controller]")]
//     [ApiController]
//     public class PhoneVerificationController : ControllerBase
//     {
//         private readonly SmsVerificationService _verificationService;
//         private readonly ApplicationDbContext _context;

//         public PhoneVerificationController(SmsVerificationService verificationService, ApplicationDbContext context)
//         {
//             _verificationService = verificationService;
//             _context = context;
//         }

//         [HttpPost("send-code")]
//         public async Task<IActionResult> SendVerificationCode([FromBody] PhoneVerificationRequest request)
//         {
//             try
//             {
//                 if (string.IsNullOrEmpty(request.PhoneNumber))
//                 {
//                     return BadRequest(new { message = "Phone number is required" });
//                 }

//                 var sessionInfo = await _verificationService.SendVerificationCode(request.PhoneNumber);
//                 return Ok(new
//                 {
//                     sessionInfo,
//                     message = "Verification code generated. Check the server console output to get the code."
//                 });
//             }
//             catch (Exception ex)
//             {
//                 return BadRequest(new { message = $"Failed to send verification code: {ex.Message}" });
//             }
//         }

//         [HttpPost("verify")]
//         public async Task<IActionResult> VerifyPhoneNumber([FromBody] VerifyPhoneRequest request)
//         {
//             if (string.IsNullOrEmpty(request.PhoneNumber) || string.IsNullOrEmpty(request.Code))
//             {
//                 return BadRequest(new { message = "Phone number and verification code are required" });
//             }

//             var isVerified = await _verificationService.VerifyPhoneNumber(
//                 request.SessionInfo, request.Code, request.PhoneNumber);

//             if (isVerified)
//             {
//                 if (request.UserId > 0)
//                 {
//                     var user = await _context.Users.FindAsync(request.UserId);
//                     if (user != null)
//                     {
//                         user.PhoneNumber = request.PhoneNumber;
//                         user.IsPhoneVerified = true; // Make sure this field exists
//                         await _context.SaveChangesAsync();
//                     }
//                 }

//                 return Ok(new { message = "Phone number verified successfully" });
//             }

//             return BadRequest(new { message = "Invalid verification code" });
//         }
//     }
// }using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using DocManagementBackend.Mappings;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class SousLignesController : ControllerBase
    {
        private readonly ApplicationDbContext _context;

        public SousLignesController(ApplicationDbContext context) { _context = context; }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<SousLigne>>> GetSousLignes() {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            var sousLigne = await _context.SousLignes
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(SousLigneMappings.ToSousLigneDto).ToListAsync();
            return Ok(sousLigne);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<SousLigne>> GetSousLigne(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            var sousLigne = await _context.SousLignes
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(SousLigneMappings.ToSousLigneDto).FirstOrDefaultAsync(s => s.Id == id);

            if (sousLigne == null)
                return NotFound("SousLigne not found.");

            return Ok(sousLigne);
        }

        [HttpGet("by_ligne/{id}")]
        public async Task<ActionResult<SousLigne>> GetSousLigneByLigneId(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            var sousLigne = await _context.SousLignes
                .Where(s => s.LigneId == id)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(SousLigneMappings.ToSousLigneDto).ToListAsync();
            if (sousLigne == null)
                return NotFound("No SousLigne found with that ligne.");
            return Ok(sousLigne);
        }

        [HttpGet("by_document/{id}")]
        public async Task<ActionResult<SousLigne>> GetSousLigneByDocId(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            var sousLigne = await _context.SousLignes
                .Where(s => s.Ligne!.DocumentId == id)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(SousLigneMappings.ToSousLigneDto).ToListAsync();
            if (sousLigne == null)
                return NotFound("No SousLigne found linked to document.");
            return Ok(sousLigne);
        }

        [HttpPost]
        public async Task<ActionResult<SousLigne>> CreateSousLigne([FromBody] SousLigne sousLigne)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin" && ThisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action.");
            var ligne = await _context.Lignes.FindAsync(sousLigne.LigneId);
            if (ligne == null)
                return BadRequest("Invalid LigneId. Ligne not found.");
            sousLigne.CreatedAt = DateTime.UtcNow;
            sousLigne.UpdatedAt = DateTime.UtcNow;
            sousLigne.SousLigneKey = $"{ligne.LigneKey}SL{ligne.SousLigneCounter++}";
            _context.SousLignes.Add(sousLigne);
            await _context.SaveChangesAsync();
            var sousLigneDto = await _context.SousLignes
                .Where(s => s.Id == sousLigne.Id)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.DocumentType)
                .Include(s => s.Ligne!).ThenInclude(l => l.Document!).ThenInclude(d => d.CreatedBy).ThenInclude(u => u.Role)
                .Select(SousLigneMappings.ToSousLigneDto).ToListAsync();
            return CreatedAtAction(nameof(GetSousLigne), new { id = sousLigne.Id }, sousLigneDto);
        }

        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateSousLigne(int id, [FromBody] SousLigne updatedSousLigne)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin" && ThisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action.");
            var sousLigne = await _context.SousLignes.FindAsync(id);
            if (sousLigne == null)
                return NotFound("SousLigne not found.");
            if (!string.IsNullOrEmpty(updatedSousLigne.Title))
                sousLigne.Title = updatedSousLigne.Title;
            if (!string.IsNullOrEmpty(updatedSousLigne.Attribute))
                sousLigne.Attribute = updatedSousLigne.Attribute;
            sousLigne.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();
            return Ok("SousLigne updated!");
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteSousLigne(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");
            int userId = int.Parse(userIdClaim);
            var ThisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (ThisUser == null)
                return BadRequest("User not found.");
            if (!ThisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (ThisUser.Role!.RoleName != "Admin" && ThisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User Not Allowed To do this action.");
            var sousLigne = await _context.SousLignes.FindAsync(id);
            if (sousLigne == null)
                return NotFound("SousLigne not found.");
            _context.SousLignes.Remove(sousLigne);
            await _context.SaveChangesAsync();
            return Ok("SousLigne deleted!");
        }
    }
}
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class StatusController : ControllerBase
    {
        private readonly ApplicationDbContext _context;

        public StatusController(ApplicationDbContext context)
        {
            _context = context;
        }

        [HttpGet("step/{stepId}")]
        public async Task<ActionResult<IEnumerable<StatusDto>>> GetStatusesForStep(int stepId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var statuses = await _context.Status
                .Where(s => s.StepId == stepId)
                .OrderBy(s => s.Id)
                .Select(s => new StatusDto
                {
                    StatusId = s.Id,
                    StatusKey = s.StatusKey,
                    Title = s.Title,
                    IsRequired = s.IsRequired,
                    IsComplete = s.IsComplete,
                    StepId = s.StepId
                })
                .ToListAsync();

            return Ok(statuses);
        }

        [HttpPost("step/{stepId}")]
        public async Task<ActionResult<StatusDto>> AddStatusToStep(int stepId, [FromBody] CreateStatusDto createStatusDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to add statuses.");

            var step = await _context.Steps.FindAsync(stepId);
            if (step == null)
                return NotFound("Step not found.");

            var status = new Status
            {
                StepId = stepId,
                Title = createStatusDto.Title,
                IsRequired = createStatusDto.IsRequired,
                IsComplete = false,
                StatusKey = $"ST-{Guid.NewGuid().ToString().Substring(0, 3)}"
            };

            _context.Status.Add(status);
            await _context.SaveChangesAsync();

            return CreatedAtAction(nameof(GetStatusesForStep), new { stepId = stepId }, new StatusDto
            {
                StatusId = status.Id,
                StatusKey = status.StatusKey,
                Title = status.Title,
                IsRequired = status.IsRequired,
                IsComplete = status.IsComplete,
                StepId = status.StepId
            });
        }

        [HttpPut("{statusId}")]
        public async Task<IActionResult> UpdateStatus(int statusId, [FromBody] CreateStatusDto updateStatusDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to update statuses.");

            var status = await _context.Status.FindAsync(statusId);
            if (status == null)
                return NotFound("Status not found.");

            if (!string.IsNullOrEmpty(updateStatusDto.Title))
                status.Title = updateStatusDto.Title;
            status.IsRequired = updateStatusDto.IsRequired;
            // status.IsComplete = updateStatusDto.IsComplete;

            await _context.SaveChangesAsync();
            return Ok("Status updated successfully.");
        }

        [HttpDelete("{statusId}")]
        public async Task<IActionResult> DeleteStatus(int statusId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to delete statuses.");

            var status = await _context.Status.FindAsync(statusId);
            if (status == null)
                return NotFound("Status not found.");

            // Check if documents are already using this status
            var inUse = await _context.DocumentStatus.AnyAsync(ds => ds.StatusId == statusId);
            if (inUse)
                return BadRequest("Cannot delete status that is in use by documents.");

            _context.Status.Remove(status);
            await _context.SaveChangesAsync();

            return Ok("Status deleted successfully.");
        }
    }
}using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class SubTypeController : ControllerBase
    {
        private readonly ApplicationDbContext _context;

        public SubTypeController(ApplicationDbContext context)
        {
            _context = context;
        }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<SubTypeDto>>> GetSubTypes()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var subTypes = await _context.SubTypes
                .Include(st => st.DocumentType)
                .Select(st => new SubTypeDto
                {
                    Id = st.Id,
                    SubTypeKey = st.SubTypeKey,
                    Name = st.Name,
                    Description = st.Description,
                    StartDate = st.StartDate,
                    EndDate = st.EndDate,
                    DocumentTypeId = st.DocumentTypeId,
                    IsActive = st.IsActive,
                    DocumentType = new DocumentTypeDto
                    {
                        TypeKey = st.DocumentType!.TypeKey,
                        TypeName = st.DocumentType.TypeName,
                        TypeAttr = st.DocumentType.TypeAttr
                    }
                })
                .ToListAsync();

            return Ok(subTypes);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<SubTypeDto>> GetSubType(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var subType = await _context.SubTypes
                .Include(st => st.DocumentType)
                .Where(st => st.Id == id)
                .Select(st => new SubTypeDto
                {
                    Id = st.Id,
                    SubTypeKey = st.SubTypeKey,
                    Name = st.Name,
                    Description = st.Description,
                    StartDate = st.StartDate,
                    EndDate = st.EndDate,
                    DocumentTypeId = st.DocumentTypeId,
                    IsActive = st.IsActive,
                    DocumentType = new DocumentTypeDto
                    {
                        TypeKey = st.DocumentType!.TypeKey,
                        TypeName = st.DocumentType.TypeName,
                        TypeAttr = st.DocumentType.TypeAttr
                    }
                })
                .FirstOrDefaultAsync();

            if (subType == null)
                return NotFound("SubType not found.");

            return Ok(subType);
        }

        [HttpGet("by-document-type/{docTypeId}")]
        public async Task<ActionResult<IEnumerable<SubTypeDto>>> GetSubTypesByDocType(int docTypeId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var subTypes = await _context.SubTypes
                .Include(st => st.DocumentType)
                .Where(st => st.DocumentTypeId == docTypeId && st.IsActive)
                .Select(st => new SubTypeDto
                {
                    Id = st.Id,
                    SubTypeKey = st.SubTypeKey,
                    Name = st.Name,
                    Description = st.Description,
                    StartDate = st.StartDate,
                    EndDate = st.EndDate,
                    DocumentTypeId = st.DocumentTypeId,
                    IsActive = st.IsActive,
                    DocumentType = new DocumentTypeDto
                    {
                        TypeKey = st.DocumentType!.TypeKey,
                        TypeName = st.DocumentType.TypeName,
                        TypeAttr = st.DocumentType.TypeAttr
                    }
                })
                .ToListAsync();

            return Ok(subTypes);
        }

        [HttpGet("for-date/{docTypeId}/{date}")]
        public async Task<ActionResult<IEnumerable<SubTypeDto>>> GetSubTypesForDate(int docTypeId, DateTime date)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            var subTypes = await _context.SubTypes
                .Include(st => st.DocumentType)
                .Where(st => st.DocumentTypeId == docTypeId &&
                             st.IsActive &&
                             st.StartDate <= date &&
                             st.EndDate >= date)
                .Select(st => new SubTypeDto
                {
                    Id = st.Id,
                    SubTypeKey = st.SubTypeKey,
                    Name = st.Name,
                    Description = st.Description,
                    StartDate = st.StartDate,
                    EndDate = st.EndDate,
                    DocumentTypeId = st.DocumentTypeId,
                    IsActive = st.IsActive,
                    DocumentType = new DocumentTypeDto
                    {
                        TypeKey = st.DocumentType!.TypeKey,
                        TypeName = st.DocumentType.TypeName,
                        TypeAttr = st.DocumentType.TypeAttr
                    }
                })
                .ToListAsync();

            return Ok(subTypes);
        }

        [HttpPost]
        public async Task<ActionResult<SubTypeDto>> CreateSubType([FromBody] CreateSubTypeDto createSubTypeDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (thisUser.Role!.RoleName != "Admin" && thisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to create subtypes.");

            // Check if DocumentType exists
            var documentType = await _context.DocumentTypes.FindAsync(createSubTypeDto.DocumentTypeId);
            if (documentType == null)
                return BadRequest("Invalid Document Type ID.");

            // Validate date range
            if (createSubTypeDto.StartDate >= createSubTypeDto.EndDate)
                return BadRequest("Start date must be before end date.");

            // Check for overlapping periods with the same name for this document type
            var overlappingSubType = await _context.SubTypes
                .Where(st => st.DocumentTypeId == createSubTypeDto.DocumentTypeId &&
                             st.Name.ToLower() == createSubTypeDto.Name.ToLower() &&
                             ((st.StartDate <= createSubTypeDto.StartDate && st.EndDate >= createSubTypeDto.StartDate) ||
                              (st.StartDate <= createSubTypeDto.EndDate && st.EndDate >= createSubTypeDto.EndDate) ||
                              (st.StartDate >= createSubTypeDto.StartDate && st.EndDate <= createSubTypeDto.EndDate)))
                .FirstOrDefaultAsync();

            if (overlappingSubType != null)
                return BadRequest($"A subtype with name '{createSubTypeDto.Name}' already exists for this document type within the specified date range.");

            // Generate the SubTypeKey
            // Format example: {TypeKey}{FirstLettersOfName}{YearEnd} = "FAAB25"
            string namePrefix = string.Join("", createSubTypeDto.Name.Take(2)).ToUpper();
            string yearSuffix = createSubTypeDto.EndDate.ToString("yy"); // 2-digit year
            string subTypeKey = $"{documentType.TypeKey}{namePrefix}{yearSuffix}";

            // Check if this key already exists, if so, make it unique
            bool keyExists = await _context.SubTypes.AnyAsync(st => st.SubTypeKey == subTypeKey);
            if (keyExists)
            {
                // Add a numeric suffix until we find a unique key
                int counter = 1;
                string newKey;
                do
                {
                    newKey = $"{subTypeKey}{counter}";
                    keyExists = await _context.SubTypes.AnyAsync(st => st.SubTypeKey == newKey);
                    counter++;
                } while (keyExists && counter < 100);

                subTypeKey = newKey;
            }

            var subType = new SubType
            {
                Name = createSubTypeDto.Name,
                Description = createSubTypeDto.Description,
                StartDate = createSubTypeDto.StartDate,
                EndDate = createSubTypeDto.EndDate,
                DocumentTypeId = createSubTypeDto.DocumentTypeId,
                IsActive = createSubTypeDto.IsActive,
                SubTypeKey = subTypeKey
            };

            _context.SubTypes.Add(subType);
            await _context.SaveChangesAsync();

            var subTypeDto = new SubTypeDto
            {
                Id = subType.Id,
                SubTypeKey = subType.SubTypeKey,
                Name = subType.Name,
                Description = subType.Description,
                StartDate = subType.StartDate,
                EndDate = subType.EndDate,
                DocumentTypeId = subType.DocumentTypeId,
                IsActive = subType.IsActive,
                DocumentType = new DocumentTypeDto
                {
                    TypeKey = documentType.TypeKey,
                    TypeName = documentType.TypeName,
                    TypeAttr = documentType.TypeAttr
                }
            };

            return CreatedAtAction(nameof(GetSubType), new { id = subType.Id }, subTypeDto);
        }

        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateSubType(int id, [FromBody] UpdateSubTypeDto updateSubTypeDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (thisUser.Role!.RoleName != "Admin" && thisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to update subtypes.");

            var subType = await _context.SubTypes.FindAsync(id);
            if (subType == null)
                return NotFound("SubType not found.");

            // Check if we need to update dates and validate
            DateTime startDate = updateSubTypeDto.StartDate ?? subType.StartDate;
            DateTime endDate = updateSubTypeDto.EndDate ?? subType.EndDate;

            if (startDate >= endDate)
                return BadRequest("Start date must be before end date.");

            // Check for name update and potential overlaps
            string name = updateSubTypeDto.Name ?? subType.Name;

            if (updateSubTypeDto.Name != null || updateSubTypeDto.StartDate.HasValue || updateSubTypeDto.EndDate.HasValue)
            {
                // Check for overlapping periods with the same name for this document type
                var overlappingSubType = await _context.SubTypes
                    .Where(st => st.Id != id &&
                                 st.DocumentTypeId == subType.DocumentTypeId &&
                                 st.Name.ToLower() == name.ToLower() &&
                                 ((st.StartDate <= startDate && st.EndDate >= startDate) ||
                                  (st.StartDate <= endDate && st.EndDate >= endDate) ||
                                  (st.StartDate >= startDate && st.EndDate <= endDate)))
                    .FirstOrDefaultAsync();

                if (overlappingSubType != null)
                    return BadRequest($"A subtype with name '{name}' already exists for this document type within the specified date range.");
            }

            // Update the SubType
            if (updateSubTypeDto.Name != null)
                subType.Name = updateSubTypeDto.Name;

            if (updateSubTypeDto.Description != null)
                subType.Description = updateSubTypeDto.Description;

            if (updateSubTypeDto.StartDate.HasValue)
                subType.StartDate = updateSubTypeDto.StartDate.Value;

            if (updateSubTypeDto.EndDate.HasValue)
                subType.EndDate = updateSubTypeDto.EndDate.Value;

            if (updateSubTypeDto.IsActive.HasValue)
                subType.IsActive = updateSubTypeDto.IsActive.Value;

            // If the name or dates changed, update the SubTypeKey
            if (updateSubTypeDto.Name != null || updateSubTypeDto.EndDate.HasValue)
            {
                var documentType = await _context.DocumentTypes.FindAsync(subType.DocumentTypeId);
                if (documentType != null)
                {
                    string namePrefix = string.Join("", subType.Name.Take(2)).ToUpper();
                    string yearSuffix = subType.EndDate.ToString("yy"); // 2-digit year
                    string newSubTypeKey = $"{documentType.TypeKey}{namePrefix}{yearSuffix}";

                    // Check if this key already exists, if so, make it unique
                    bool keyExists = await _context.SubTypes.AnyAsync(st => st.SubTypeKey == newSubTypeKey && st.Id != id);
                    if (keyExists)
                    {
                        // Add a numeric suffix until we find a unique key
                        int counter = 1;
                        string tempKey;
                        do
                        {
                            tempKey = $"{newSubTypeKey}{counter}";
                            keyExists = await _context.SubTypes.AnyAsync(st => st.SubTypeKey == tempKey && st.Id != id);
                            counter++;
                        } while (keyExists && counter < 100);

                        newSubTypeKey = tempKey;
                    }

                    subType.SubTypeKey = newSubTypeKey;
                }
                else
                {
                    return BadRequest("Document type not found.");
                }
            }

            try
            {
                await _context.SaveChangesAsync();
                return Ok("SubType updated successfully");
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!await _context.SubTypes.AnyAsync(st => st.Id == id))
                    return NotFound("SubType not found");
                throw;
            }
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteSubType(int id)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var thisUser = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
            if (thisUser == null)
                return BadRequest("User not found.");
            if (!thisUser.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");
            if (thisUser.Role!.RoleName != "Admin" && thisUser.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to delete subtypes.");

            var subType = await _context.SubTypes.FindAsync(id);
            if (subType == null)
                return NotFound("SubType not found.");

            // Check if this subtype is used by any documents
            bool isUsed = await _context.Documents.AnyAsync(d => d.SubTypeId == id);
            if (isUsed)
                return BadRequest("Cannot delete this subtype because it is used by one or more documents.");

            _context.SubTypes.Remove(subType);
            await _context.SaveChangesAsync();

            return Ok("SubType deleted successfully.");
        }
    }
}using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using DocManagementBackend.Services;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class WorkflowController : ControllerBase
    {
        private readonly DocumentWorkflowService _workflowService;
        private readonly ApplicationDbContext _context;

        public WorkflowController(DocumentWorkflowService workflowService, ApplicationDbContext context)
        {
            _workflowService = workflowService;
            _context = context;
        }

        [HttpPost("assign-circuit")]
        public async Task<IActionResult> AssignDocumentToCircuit([FromBody] AssignCircuitDto assignCircuitDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to assign documents to circuits.");

            try
            {
                var success = await _workflowService.AssignDocumentToCircuitAsync(
                    assignCircuitDto.DocumentId, assignCircuitDto.CircuitId, userId);

                if (success)
                    return Ok("Document assigned to circuit successfully.");
                else
                    return BadRequest("Failed to assign document to circuit.");
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpPost("perform-action")]
        public async Task<IActionResult> PerformAction([FromBody] PerformActionDto actionDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to do this action.");

            try
            {
                var success = await _workflowService.ProcessActionAsync(
                    actionDto.DocumentId, actionDto.ActionId, userId, actionDto.Comments, actionDto.IsApproved);

                if (success)
                    return Ok("Action performed successfully.");
                else
                    return BadRequest("Failed to perform action.");
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);
            }
            catch (UnauthorizedAccessException ex)
            {
                return Unauthorized(ex.Message);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpPost("change-step")]
        public async Task<IActionResult> MoveToNextStep([FromBody] MoveNextDto moveNextDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to perform this action.");

            try
            {
                var success = await _workflowService.MoveToNextStepAsync(
                    moveNextDto.DocumentId,
                    moveNextDto.CurrentStepId,
                    moveNextDto.NextStepId,
                    userId,
                    moveNextDto.Comments);

                if (success)
                    return Ok("Document moved to next step successfully.");
                else
                    return BadRequest("Failed to move document to next step.");
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);
            }
            catch (UnauthorizedAccessException ex)
            {
                return Unauthorized(ex.Message);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpPost("move-next")]
        public async Task<IActionResult> MoveToNextStep([FromBody] MoveToDocumentDto moveDocumentDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to perform this action.");

            try
            {
                // Get the document and its current step
                var document = await _context.Documents
                    .Include(d => d.Circuit)
                    .Include(d => d.CurrentStep)
                    .FirstOrDefaultAsync(d => d.Id == moveDocumentDto.DocumentId);

                if (document == null)
                    return NotFound("Document not found.");

                if (document.CurrentStepId == null)
                    return BadRequest("Document is not currently in any workflow step.");

                if (document.CircuitId == null)
                    return BadRequest("Document is not assigned to any circuit.");

                // Find the next step based on order index
                var currentStep = await _context.Steps.FindAsync(document.CurrentStepId);
                if (currentStep == null)
                    return BadRequest("Current step not found.");

                // Get all steps in the circuit ordered by OrderIndex
                var circuitSteps = await _context.Steps
                    .Where(s => s.CircuitId == document.CircuitId)
                    .OrderBy(s => s.OrderIndex)
                    .ToListAsync();

                // Find the next step
                Step? nextStep = null;
                for (int i = 0; i < circuitSteps.Count; i++)
                {
                    if (circuitSteps[i].Id == currentStep.Id && i < circuitSteps.Count - 1)
                    {
                        nextStep = circuitSteps[i + 1];
                        break;
                    }
                }

                if (nextStep == null)
                {
                    // Check if current step is final
                    if (currentStep.IsFinalStep)
                        return BadRequest("Current step is the final step in the workflow.");
                    else
                        return BadRequest("No next step found in the workflow.");
                }

                // Pass to the service method
                var success = await _workflowService.MoveToNextStepAsync(
                    moveDocumentDto.DocumentId,
                    currentStep.Id,
                    nextStep.Id,
                    userId,
                    moveDocumentDto.Comments);

                if (success)
                    return Ok("Document moved to next step successfully.");
                else
                    return BadRequest("Failed to move document to next step.");
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);
            }
            catch (UnauthorizedAccessException ex)
            {
                return Unauthorized(ex.Message);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpPost("return-to-previous")]
        public async Task<IActionResult> ReturnToPreviousStep([FromBody] ReturnToPreviousDto returnDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            if (user.Role!.RoleName != "Admin" && user.Role!.RoleName != "FullUser")
                return Unauthorized("User not allowed to do action.");

            try
            {
                var success = await _workflowService.ReturnToPreviousStepAsync(
                    returnDto.DocumentId, userId, returnDto.Comments);

                if (success)
                    return Ok("Document returned to previous step successfully.");
                else
                    return BadRequest("Failed to return document to previous step.");
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpPost("complete-status")]
        public async Task<IActionResult> CompleteDocumentStatus([FromBody] CompleteStatusDto completeStatusDto)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            try
            {
                var success = await _workflowService.CompleteDocumentStatusAsync(
                    completeStatusDto.DocumentId,
                    completeStatusDto.StatusId,
                    userId,
                    completeStatusDto.IsComplete,
                    completeStatusDto.Comments);

                if (success)
                    return Ok("Document status updated successfully.");
                else
                    return BadRequest("Failed to update document status.");
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(ex.Message);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(ex.Message);
            }
            catch (UnauthorizedAccessException ex)
            {
                return Unauthorized(ex.Message);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpGet("document/{documentId}/step-statuses")]
        public async Task<ActionResult<IEnumerable<DocumentStatusDto>>> GetDocumentStepStatuses(int documentId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role)
                .FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            // Get the document and check if it has a current step
            var document = await _context.Documents
                .Include(d => d.CurrentStep)
                .FirstOrDefaultAsync(d => d.Id == documentId);

            if (document == null)
                return NotFound("Document not found.");

            if (document.CurrentStepId == null)
                return NotFound("Document is not currently in any workflow step.");

            // Get statuses for the current step with completion info for this document
            var statuses = await _context.Status
                .Where(s => s.StepId == document.CurrentStepId)
                .OrderBy(s => s.Id)
                .Select(s => new
                {
                    Status = s,
                    DocumentStatus = _context.DocumentStatus
                        .FirstOrDefault(ds => ds.DocumentId == documentId && ds.StatusId == s.Id)
                })
                .ToListAsync();

            var statusDtos = statuses.Select(item => new DocumentStatusDto
            {
                StatusId = item.Status.Id,
                Title = item.Status.Title,
                IsRequired = item.Status.IsRequired,
                IsComplete = item.DocumentStatus?.IsComplete ?? false,
                CompletedBy = item.DocumentStatus != null && item.DocumentStatus.CompletedByUserId.HasValue
                    ? _context.Users
                        .Where(u => u.Id == item.DocumentStatus.CompletedByUserId.Value)
                        .Select(u => u.Username)
                        .FirstOrDefault()
                    : null,
                CompletedAt = item.DocumentStatus?.CompletedAt
            }).ToList();

            return Ok(statusDtos);
        }

        [HttpGet("document/{documentId}/history")]
        public async Task<ActionResult<IEnumerable<DocumentHistoryDto>>> GetDocumentHistory(int documentId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            try
            {
                var history = await _context.DocumentCircuitHistory
                    .Where(h => h.DocumentId == documentId)
                    .Include(h => h.Step)
                    .Include(h => h.ProcessedBy)
                    .Include(h => h.Action)
                    .Include(h => h.Status)
                    .OrderByDescending(h => h.ProcessedAt)
                    .ToListAsync();

                var historyDtos = history.Select(h => new DocumentHistoryDto
                {
                    Id = h.Id,
                    StepTitle = h.Step?.Title ?? "N/A",
                    ActionTitle = h.Action?.Title ?? "N/A",
                    StatusTitle = h.Status?.Title ?? "N/A",
                    ProcessedBy = h.ProcessedBy?.Username ?? "System",
                    ProcessedAt = h.ProcessedAt,
                    Comments = h.Comments,
                    IsApproved = h.IsApproved
                }).ToList();

                return Ok(historyDtos);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpGet("document/{documentId}/current-status")]
        public async Task<ActionResult<DocumentWorkflowStatusDto>> GetDocumentCurrentStatus(int documentId)
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            try
            {
                var document = await _context.Documents
                    .Include(d => d.Circuit)
                    .Include(d => d.CurrentStep)
                    .FirstOrDefaultAsync(d => d.Id == documentId);

                if (document == null)
                    return NotFound("Document not found.");

                // Get current step's statuses with completion info
                var statusesQuery = from s in _context.Status
                                    where s.StepId == document.CurrentStepId
                                    join ds in _context.DocumentStatus
                                      on new { StatusId = s.Id, DocumentId = document.Id }
                                      equals new { StatusId = ds.StatusId, DocumentId = ds.DocumentId } into dsGroup
                                    from ds in dsGroup.DefaultIfEmpty()
                                    select new DocumentStatusDto
                                    {
                                        StatusId = s.Id,
                                        Title = s.Title,
                                        IsRequired = s.IsRequired,
                                        IsComplete = ds != null && ds.IsComplete,
                                        CompletedBy = ds != null && ds.CompletedByUserId.HasValue
                                            ? _context.Users
                                                .Where(u => u.Id == ds.CompletedByUserId.Value)
                                                .Select(u => u.Username)
                                                .FirstOrDefault()
                                            : null,
                                        CompletedAt = ds != null ? ds.CompletedAt : null
                                    };

                var statuses = await statusesQuery.ToListAsync();

                // Get actions available for current step
                var actions = await _context.StepActions
                    .Where(sa => sa.StepId == document.CurrentStepId)
                    .Select(sa => new ActionDto
                    {
                        ActionId = sa.ActionId,
                        Title = sa.Action!.Title,
                        Description = sa.Action.Description!
                    })
                    .ToListAsync();

                // Check if all required statuses are complete
                var canAdvance = statuses
                    .Where(s => s.IsRequired)
                    .All(s => s.IsComplete);

                // Check if backtracking is allowed
                var currentStep = document.CurrentStep;
                var canReturn = document.Circuit!.AllowBacktrack &&
                                currentStep != null &&
                                currentStep.PrevStepId.HasValue;

                var statusDto = new DocumentWorkflowStatusDto
                {
                    DocumentId = document.Id,
                    DocumentTitle = document.Title,
                    CircuitId = document.Circuit?.Id,
                    CircuitTitle = document.Circuit!.Title,
                    CurrentStepId = document.CurrentStepId,
                    CurrentStepTitle = document.CurrentStep!.Title,
                    Status = document.Status,
                    StatusText = GetStatusText(document.Status),
                    IsCircuitCompleted = document.IsCircuitCompleted,
                    Statuses = statuses,
                    AvailableActions = actions,
                    CanAdvanceToNextStep = canAdvance,
                    CanReturnToPreviousStep = canReturn
                };

                return Ok(statusDto);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        [HttpGet("pending-documents")]
        public async Task<ActionResult<IEnumerable<PendingDocumentDto>>> GetPendingDocuments()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null)
                return Unauthorized("User ID claim is missing.");

            int userId = int.Parse(userIdClaim);
            var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return BadRequest("User not found.");

            if (!user.IsActive)
                return Unauthorized("User account is deactivated. Please contact un admin!");

            try
            {
                // Get documents that are:
                // 1. Assigned to a circuit
                // 2. Not completed
                // 3. Current step is assigned to user's role (if role assignment is enabled)
                var pendingQuery = _context.Documents
                    .Include(d => d.Circuit)
                    .Include(d => d.CurrentStep)
                    .Include(d => d.CreatedBy)
                    .Where(d =>
                        d.CircuitId.HasValue &&
                        !d.IsCircuitCompleted &&
                        d.Status == 1 && // In Progress
                        d.CurrentStepId.HasValue);

                // Add role-based filtering if step has role assignment
                if (user.RoleId > 0) // Or another appropriate condition
                {
                    // For the first error - ensure CurrentStep is not null before accessing its properties
                    pendingQuery = pendingQuery.Where(d =>
                        d.CurrentStep != null &&
                        (!d.CurrentStep.ResponsibleRoleId.HasValue ||
                         d.CurrentStep.ResponsibleRoleId == user.RoleId));
                }

                var pendingDocuments = await pendingQuery.ToListAsync();

                var pendingDtos = pendingDocuments.Select(d => new PendingDocumentDto
                {
                    DocumentId = d.Id,
                    DocumentKey = d.DocumentKey,
                    Title = d.Title,
                    CreatedBy = d.CreatedBy?.Username ?? "Unknown",
                    CreatedAt = d.CreatedAt,
                    CircuitId = d.CircuitId!.Value,
                    CircuitTitle = d.Circuit?.Title ?? "Unknown",
                    CurrentStepId = d.CurrentStepId!.Value,
                    CurrentStepTitle = d.CurrentStep?.Title ?? "Unknown",
                    DaysInCurrentStep = (int)(DateTime.UtcNow - d.UpdatedAt).TotalDays
                }).ToList();

                return Ok(pendingDtos);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"An error occurred: {ex.Message}");
            }
        }

        private string GetStatusText(int status)
        {
            return status switch
            {
                0 => "Draft",
                1 => "In Progress",
                2 => "Completed",
                3 => "Rejected",
                _ => "Unknown"
            };
        }
    }
}using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Models;

namespace DocManagementBackend.Data
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options) { }
        public ApplicationDbContext() { }

        // Existing entities
        public DbSet<User> Users { get; set; }
        public DbSet<LogHistory> LogHistories { get; set; }
        public DbSet<Document> Documents { get; set; }
        public DbSet<Ligne> Lignes { get; set; }
        public DbSet<SousLigne> SousLignes { get; set; }
        public DbSet<Role> Roles { get; set; }
        public DbSet<DocumentType> DocumentTypes { get; set; }
        // New SubType entity
        public DbSet<SubType> SubTypes { get; set; }
        public DbSet<TypeCounter> TypeCounter { get; set; }
        public DbSet<Circuit> Circuits { get; set; }
        public DbSet<DocumentCircuitHistory> DocumentCircuitHistory { get; set; }

        // Workflow entities
        public DbSet<Status> Status { get; set; }
        public DbSet<Step> Steps { get; set; }
        public DbSet<Models.Action> Actions { get; set; }
        public DbSet<StepAction> StepActions { get; set; }
        public DbSet<ActionStatusEffect> ActionStatusEffects { get; set; }
        public DbSet<DocumentStatus> DocumentStatus { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // SubType relationship with Document
            modelBuilder.Entity<Document>()
                .HasOne(d => d.SubType)
                .WithMany(st => st.Documents)
                .HasForeignKey(d => d.SubTypeId)
                .OnDelete(DeleteBehavior.Restrict);

            // SubType relationship with DocumentType
            modelBuilder.Entity<SubType>()
                .HasOne(st => st.DocumentType)
                .WithMany()
                .HasForeignKey(st => st.DocumentTypeId)
                .OnDelete(DeleteBehavior.Cascade);

            // DocumentCircuitHistory relationships
            modelBuilder.Entity<DocumentCircuitHistory>()
                .HasOne(d => d.Document)
                .WithMany()
                .HasForeignKey(d => d.DocumentId)
                .OnDelete(DeleteBehavior.NoAction);

            modelBuilder.Entity<DocumentCircuitHistory>()
                .HasOne(d => d.Step)
                .WithMany()
                .HasForeignKey(d => d.StepId)
                .OnDelete(DeleteBehavior.NoAction);

            modelBuilder.Entity<DocumentCircuitHistory>()
                .HasOne(d => d.ProcessedBy)
                .WithMany()
                .HasForeignKey(d => d.ProcessedByUserId)
                .OnDelete(DeleteBehavior.NoAction);

            // Status relationships
            modelBuilder.Entity<Status>()
                .HasOne(s => s.Step)
                .WithMany(s => s.Statuses)
                .HasForeignKey(s => s.StepId);

            // StepAction relationships
            modelBuilder.Entity<StepAction>()
                .HasOne(sa => sa.Step)
                .WithMany(s => s.StepActions)
                .HasForeignKey(sa => sa.StepId);

            modelBuilder.Entity<StepAction>()
                .HasOne(sa => sa.Action)
                .WithMany(a => a.StepActions)
                .HasForeignKey(sa => sa.ActionId);

            // ActionStatusEffect relationships
            modelBuilder.Entity<ActionStatusEffect>()
                .HasOne(ase => ase.Action)
                .WithMany()
                .HasForeignKey(ase => ase.ActionId);

            modelBuilder.Entity<ActionStatusEffect>()
                .HasOne(ase => ase.Status)
                .WithMany()
                .HasForeignKey(ase => ase.StatusId);

            modelBuilder.Entity<ActionStatusEffect>()
                .HasOne(ase => ase.Step)
                .WithMany()
                .HasForeignKey(ase => ase.StepId)
                .OnDelete(DeleteBehavior.NoAction);

            // DocumentStatus relationships
            modelBuilder.Entity<DocumentStatus>()
                .HasOne(ds => ds.Document)
                .WithMany()
                .HasForeignKey(ds => ds.DocumentId);

            modelBuilder.Entity<DocumentStatus>()
                .HasOne(ds => ds.Status)
                .WithMany()
                .HasForeignKey(ds => ds.StatusId);

            // Seed data
            modelBuilder.Entity<Role>().HasData(
                new Role { Id = 1, RoleName = "Admin", IsAdmin = true },
                new Role { Id = 2, RoleName = "SimpleUser", IsSimpleUser = true },
                new Role { Id = 3, RoleName = "FullUser", IsFullUser = true }
            );
        }
    }
}using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;

namespace DocManagementBackend.Models
{
    public class Action
    {
        [Key]
        public int Id { get; set; }
        public string ActionKey { get; set; } = string.Empty;
        [Required]
        public string Title { get; set; } = string.Empty;
        public string? Description { get; set; }
        [JsonIgnore]
        public ICollection<StepAction> StepActions { get; set; } = new List<StepAction>();
    }

    public class StepAction
    {
        [Key]
        public int Id { get; set; }
        [Required]
        public int StepId { get; set; }
        [ForeignKey("StepId")]
        [JsonIgnore]
        public Step? Step { get; set; }
        [Required]
        public int ActionId { get; set; }
        [ForeignKey("ActionId")]
        [JsonIgnore]
        public Action? Action { get; set; }
    }

    public class ActionStatusEffect
    {
        [Key]
        public int Id { get; set; }
        [Required]
        public int ActionId { get; set; }
        [ForeignKey("ActionId")]
        [JsonIgnore]
        public Action? Action { get; set; }
        [Required]
        public int StepId { get; set; }
        [ForeignKey("StepId")]
        [JsonIgnore]
        public Step? Step { get; set; }
        [Required]
        public int StatusId { get; set; }
        [ForeignKey("StatusId")]
        [JsonIgnore]
        public Status? Status { get; set; }
        public bool SetsComplete { get; set; } = true;
    }
}using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;

namespace DocManagementBackend.Models
{
    public class Circuit
    {
        [Key]
        public int Id { get; set; }
        public string CircuitKey { get; set; } = string.Empty;
        [Required]
        public string Title { get; set; } = string.Empty;
        public string Descriptif { get; set; } = string.Empty;
        public bool IsActive { get; set; } = false;
        public int CrdCounter { get; set; } = 0;
        public bool HasOrderedFlow { get; set; } = false;
        public bool AllowBacktrack { get; set; } = false;
        [JsonIgnore]
        public ICollection<Step> Steps { get; set; } = new List<Step>();
    }

    public class Step
    {
        [Key]
        public int Id { get; set; }
        public string StepKey { get; set; } = string.Empty;
        [Required]
        public int CircuitId { get; set; }
        [ForeignKey("CircuitId")]
        [JsonIgnore]
        public Circuit? Circuit { get; set; }
        [Required]
        public string Title { get; set; } = string.Empty;
        public string Descriptif { get; set; } = string.Empty;
        public int OrderIndex { get; set; } = 0;
        public int? ResponsibleRoleId { get; set; }
        [ForeignKey("ResponsibleRoleId")]
        [JsonIgnore]
        public Role? ResponsibleRole { get; set; }
        public int? NextStepId { get; set; }
        [ForeignKey("NextStepId")]
        [JsonIgnore]
        public Step? NextStep { get; set; }
        public int? PrevStepId { get; set; }
        [ForeignKey("PrevStepId")]
        [JsonIgnore]
        public Step? PrevStep { get; set; }
        public bool IsFinalStep { get; set; } = false;
        [JsonIgnore]
        public ICollection<Status> Statuses { get; set; } = new List<Status>();
        [JsonIgnore]
        public ICollection<StepAction> StepActions { get; set; } = new List<StepAction>();
    }
}using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;

namespace DocManagementBackend.Models
{
    public class Document
    {
        [Key]
        public int Id { get; set; }
        [Required]
        public int CreatedByUserId { get; set; }
        [ForeignKey("CreatedByUserId")]
        public required User CreatedBy { get; set; }
        public int TypeId { get; set; }
        [ForeignKey("TypeId")]
        public DocumentType? DocumentType { get; set; }

        // New SubType relationship
        public int? SubTypeId { get; set; }
        [ForeignKey("SubTypeId")]
        public SubType? SubType { get; set; }

        public int? CurrentStepId { get; set; }
        [ForeignKey("CurrentStepId")]
        [JsonIgnore]
        public Step? CurrentStep { get; set; }
        public int? CircuitId { get; set; }
        [ForeignKey("CircuitId")]
        public Circuit? Circuit { get; set; }
        public bool IsCircuitCompleted { get; set; } = false;
        [Required]
        public string DocumentKey { get; set; } = string.Empty;
        public string DocumentAlias { get; set; } = string.Empty;
        public string Title { get; set; } = string.Empty;
        public string? Content { get; set; }
        [Required]
        public int Status { get; set; } // 0 = Open, 1 = Validated
        public DateTime DocDate { get; set; }
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
        public int LigneCouter { get; set; } = 0;
        public bool IsDeleted { get; set; } = false;
        [JsonIgnore]
        public ICollection<Ligne> Lignes { get; set; } = new List<Ligne>();
    }

    public class DocumentType
    {
        [Key]
        public int Id { get; set; }
        public string TypeKey { get; set; } = string.Empty;
        public string TypeName { get; set; } = string.Empty;
        public string TypeAttr { get; set; } = string.Empty;
        public int DocumentCounter { get; set; } = 0;
        public int DocCounter { get; set; } = 0;
        [JsonIgnore]
        public ICollection<Document> Documents { get; set; } = new List<Document>();
    }
    public class SubType
    {
        [Key]
        public int Id { get; set; }

        public string SubTypeKey { get; set; } = string.Empty;

        [Required]
        public string Name { get; set; } = string.Empty;

        public string Description { get; set; } = string.Empty;

        [Required]
        public DateTime StartDate { get; set; }

        [Required]
        public DateTime EndDate { get; set; }

        [Required]
        public int DocumentTypeId { get; set; }

        [ForeignKey("DocumentTypeId")]
        [JsonIgnore]
        public DocumentType? DocumentType { get; set; }

        public bool IsActive { get; set; } = true;

        [JsonIgnore]
        public ICollection<Document> Documents { get; set; } = new List<Document>();
    }
    public class TypeCounter
    {
        public int Id { get; set; }
        public int Counter { get; set; }
        public int circuitCounter { get; set; }
    }
    public class DocumentCircuitHistory
    {
        [Key]
        public int Id { get; set; }
        [Required]
        public int DocumentId { get; set; }
        [ForeignKey("DocumentId")]
        [JsonIgnore]
        public Document? Document { get; set; }
        [Required]
        public int StepId { get; set; }
        [ForeignKey("StepId")]
        [JsonIgnore]
        public Step? Step { get; set; }
        public int? ActionId { get; set; }
        [ForeignKey("ActionId")]
        [JsonIgnore]
        public Action? Action { get; set; }
        public int? StatusId { get; set; }
        [ForeignKey("StatusId")]
        [JsonIgnore]
        public Status? Status { get; set; }
        [Required]
        public int ProcessedByUserId { get; set; }
        [ForeignKey("ProcessedByUserId")]
        [JsonIgnore]
        public User? ProcessedBy { get; set; }
        public DateTime ProcessedAt { get; set; } = DateTime.UtcNow;
        public string Comments { get; set; } = string.Empty;
        public bool IsApproved { get; set; } = true;
    }
}using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;

namespace DocManagementBackend.Models {
    public class Ligne
    {
        [Key]
        public int Id { get; set; }
        [Required]
        public int DocumentId { get; set; }
        [ForeignKey("DocumentId")]
        [JsonIgnore]
        public Document? Document { get; set; }
        public string LigneKey { get; set; } = string.Empty;
        public string Title { get; set; } = string.Empty;
        public string Article { get; set; } = string.Empty;
        public float Prix { get; set; }
        public int SousLigneCounter { get; set; } = 0;
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
        [JsonIgnore]
        public ICollection<SousLigne> SousLignes { get; set; } = new List<SousLigne>();
    }

    public class SousLigne
    {
        [Key]
        public int Id { get; set; }
        [Required]
        public int LigneId { get; set; }
        [ForeignKey("LigneId")]
        [JsonIgnore]
        public Ligne? Ligne { get; set; }
        public string SousLigneKey { get; set; } = string.Empty;
        public string Title { get; set; } = string.Empty;
        public string Attribute { get; set; } = string.Empty;
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    }
}
using System.Text.Json.Serialization;

namespace DocManagementBackend.Models
{
    public class PhoneVerificationRequest
    {
        public string PhoneNumber { get; set; } = string.Empty;
    }

    public class VerifyPhoneRequest
    {
        public int UserId { get; set; }
        public string PhoneNumber { get; set; } = string.Empty;
        public string SessionInfo { get; set; } = string.Empty;
        public string Code { get; set; } = string.Empty;
    }

    public class SendVerificationResponse
    {
        [JsonPropertyName("sessionInfo")]
        public string SessionInfo { get; set; } = string.Empty;
    }

    public class VerifyPhoneResponse
    {
        [JsonPropertyName("idToken")]
        public string IdToken { get; set; } = string.Empty;

        [JsonPropertyName("refreshToken")]
        public string RefreshToken { get; set; } = string.Empty;
    }
}using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;

namespace DocManagementBackend.Models
{
    public class Status
    {
        [Key]
        public int Id { get; set; }
        public string StatusKey { get; set; } = string.Empty;
        [Required]
        public int StepId { get; set; }
        [ForeignKey("StepId")]
        [JsonIgnore]
        public Step? Step { get; set; }
        [Required]
        public string Title { get; set; } = string.Empty;
        public bool IsRequired { get; set; } = true;
        public bool IsComplete { get; set; } = false;
    }

    public class DocumentStatus
    {
        [Key]
        public int Id { get; set; }
        [Required]
        public int DocumentId { get; set; }
        [ForeignKey("DocumentId")]
        [JsonIgnore]
        public Document? Document { get; set; }
        [Required]
        public int StatusId { get; set; }
        [ForeignKey("StatusId")]
        [JsonIgnore]
        public Status? Status { get; set; }
        public bool IsComplete { get; set; } = false;
        public int? CompletedByUserId { get; set; }
        [ForeignKey("CompletedByUserId")]
        [JsonIgnore]
        public User? CompletedBy { get; set; }
        public DateTime? CompletedAt { get; set; }
    }
}using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;

namespace DocManagementBackend.Models {
    public class User {
        [Key]
        public int Id { get; set; }
        [Required]
        [EmailAddress]
        public string Email { get; set; } = string.Empty;
        [Required]
        public string Username { get; set; } = string.Empty;
        [Required]
        public string PasswordHash { get; set; } = string.Empty;
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public string UserType { get; set; } = string.Empty;
        public string City { get; set; } = string.Empty;
        public string Address { get; set; } = string.Empty;
        public string PhoneNumber { get; set; } = string.Empty;
        public string Country { get; set; } = string.Empty;
        public string WebSite { get; set; } = string.Empty;
        public string Identity { get; set; } = string.Empty;
        public bool IsEmailConfirmed { get; set; } = false;
        public string? EmailVerificationCode { get; set; }
        public bool IsPhoneVerified { get; set; } = false;
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public bool IsActive { get; set; } = false;
        public bool IsOnline { get; set; } = false;
        public DateTime? LastLogin { get; set; }
        public string? ProfilePicture { get; set; }
        public string? BackgroundPicture { get; set; }
        public string? RefreshToken { get; set; }
        public DateTime? RefreshTokenExpiry { get; set; }
        public int RoleId { get; set; }
        [ForeignKey("RoleId")]
        [JsonIgnore]
        public Role? Role { get; set; }
        [JsonIgnore]
        public ICollection<LogHistory> LogHistories { get; set; } = new List<LogHistory>();
        [JsonIgnore]
        public ICollection<Document> Documents { get; set; } = new List<Document>();
    }

    public class Role {
        [Key]
        public int Id { get; set; }
        [Required]
        public string? RoleName { get; set; } = string.Empty;
        public bool IsAdmin { get; set; } = false;
        public bool IsSimpleUser { get; set; } = false;
        public bool IsFullUser { get; set; } = false;
    }

    public class LogHistory {
        [Key]
        public int Id { get; set; }
        [Required]
        public int UserId { get; set; }
        [ForeignKey("UserId")]
        public required User User { get; set; }
        [Required]
        public DateTime Timestamp { get; set; }
        [Required]
        public int ActionType { get; set; } //  0 for Logout, 1 for Login, 2 create his profile, 3 update his profile, 4 create doc, 5 update doc, 6 delete doc, 7 create profile, 8 update profile, 9 delete profile
        public string Description { get; set; } = string.Empty;
    }
}
namespace DocManagementBackend.Models
{
    public class ForgotPasswordRequest
    {
        public string Email { get; set; } = string.Empty;
        public string NewPassword { get; set; } = string.Empty;
    }
    public class ValideUsernameRequest
    {
        public string Username { get; set; } = string.Empty;
        public string Email { get; set; } = string.Empty;
    }

    public class ResetPasswordRequest
    {
        public string Email { get; set; } = string.Empty;
        public string VerificationCode { get; set; } = string.Empty;
        public string NewPassword { get; set; } = string.Empty;
    }

    public class UpdateProfileRequest
    {
        public string? FirstName { get; set; }
        public string? LastName { get; set; }
        public string? Username { get; set; }
        public string? ProfilePicture { get; set; }
        public string? Country { get; set; }
        public string? City { get; set; }
        public string? PhoneNumber { get; set; }
        public string? Address { get; set; }
        public string? BackgroundPicture { get; set; }
        public string? CurrentPassword { get; set; }
        public string? NewPassword { get; set; }
    }

    public class UpdateEmailRequest {
        public string? Email { get; set; }
    }
}
namespace DocManagementBackend.Models
{
    public class CreateActionDto
    {
        public string Title { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
    }

    public class ActionDto
    {
        public int ActionId { get; set; }
        public string ActionKey { get; set; } = string.Empty;
        public string Title { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
    }

    public class AssignActionToStepDto
    {
        public int StepId { get; set; }
        public int ActionId { get; set; }
        public List<StatusEffectDto>? StatusEffects { get; set; }
    }

    public class StatusEffectDto
    {
        public int StatusId { get; set; }
        public bool SetsComplete { get; set; }
    }
}namespace DocManagementBackend.Models
{
    public class AdminCreateUserRequest
    {
        public string Email { get; set; } = string.Empty;
        public string Username { get; set; } = string.Empty;
        public string PasswordHash { get; set; } = string.Empty;
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public string RoleName { get; set; } = string.Empty;
    }
    public class AdminUpdateUserRequest
    {
        public string? Email { get; set; } = string.Empty;

        public string? Username { get; set; } = string.Empty;

        public string? PasswordHash { get; set; } = string.Empty;

        public string? FirstName { get; set; }
        public string? LastName { get; set; }
        public bool? IsEmailConfirmed { get; set; }
        public string? RoleName { get; set; }
        public bool? IsActive { get; set; }
    }

}
namespace DocManagementBackend.Models {
    public class LoginRequest
    {
        public string EmailOrUsername { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty;
    }
    public class LogoutRequest { public int UserId { get; set; } }

    public class VerifyEmailRequest
    {
        public string? Email { get; set; }
        public string? VerificationCode { get; set; }
    }

    public class JwtSettings
    {
        public string SecretKey { get; set; } = string.Empty;
        public string Issuer { get; set; } = string.Empty;
        public string Audience { get; set; } = string.Empty;
        public int ExpiryMinutes { get; set; } = 180;
    }
}namespace DocManagementBackend.Models
{
    public class CreateCircuitDto
    {
        public string Title { get; set; } = string.Empty;
        public string Descriptif { get; set; } = string.Empty;
        public bool HasOrderedFlow { get; set; } = false;
        public bool AllowBacktrack { get; set; } = false;
        public bool IsActive { get; set; } = false;
    }

    public class CircuitDto
    {
        public int Id { get; set; }
        public string CircuitKey { get; set; } = string.Empty;
        public string Title { get; set; } = string.Empty;
        public string Descriptif { get; set; } = string.Empty;
        public bool IsActive { get; set; }
        public bool HasOrderedFlow { get; set; }
        public bool AllowBacktrack { get; set; }
        public List<StepDto> Steps { get; set; } = new();
    }

    public class CreateStepDto
    {
        public string Title { get; set; } = string.Empty;
        public string Descriptif { get; set; } = string.Empty;
        public int OrderIndex { get; set; } = 0;
        public int? ResponsibleRoleId { get; set; }
    }
    public class UpdateStepDto
    {
        public string? Title { get; set; }
        public string? Descriptif { get; set; }
        public int? OrderIndex { get; set; }
        public int? ResponsibleRoleId { get; set; }
        public bool? IsFinalStep { get; set; }
    }

    public class StepDto
    {
        public int Id { get; set; }
        public string StepKey { get; set; } = string.Empty;
        public int CircuitId { get; set; }
        public string Title { get; set; } = string.Empty;
        public string Descriptif { get; set; } = string.Empty;
        public int OrderIndex { get; set; }
        public int? ResponsibleRoleId { get; set; }
        public bool IsFinalStep { get; set; }
    }

    public class StepOrderUpdateDto
    {
        public int StepId { get; set; }
        public int OrderIndex { get; set; }
    }
}namespace DocManagementBackend.Models
{

    public class CreateDocumentRequest
    {
        public string Title { get; set; } = string.Empty;
        public string? Content { get; set; }
        public int TypeId { get; set; }
        public int? SubTypeId { get; set; }
        public string? DocumentAlias { get; set; }
        public DateTime? DocDate { get; set; }
        public int? CircuitId { get; set; }
    }

    public class UpdateDocumentRequest
    {
        public string? Title { get; set; }
        public string? Content { get; set; }
        public int? TypeId { get; set; }
        public int? SubTypeId { get; set; }
        public string? DocumentAlias { get; set; }
        public DateTime? DocDate { get; set; }
        public int? CircuitId { get; set; }
    }
    public class DocumentDto
    {
        public int Id { get; set; }
        public string DocumentKey { get; set; } = string.Empty;
        public string DocumentAlias { get; set; } = string.Empty;
        public string Title { get; set; } = string.Empty;
        public string? Content { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime UpdatedAt { get; set; }
        public DateTime DocDate { get; set; }
        public int Status { get; set; }
        public int TypeId { get; set; }
        public DocumentTypeDto? DocumentType { get; set; }
        public int? SubTypeId { get; set; }
        public SubTypeDto? SubType { get; set; }
        public int CreatedByUserId { get; set; }
        public DocumentUserDto? CreatedBy { get; set; }
        public int LignesCount { get; set; }
        public int SousLignesCount { get; set; }
        public int? CircuitId { get; set; }
        public int? CurrentStepId { get; set; }
        public string CurrentStepTitle { get; set; } = string.Empty;
        public bool IsCircuitCompleted { get; set; }
    }
}

    public class DocumentTypeDto
    {
        public string TypeAlias { get; set; } = string.Empty;
        public string TypeKey { get; set; } = string.Empty;
        public string TypeName { get; set; } = string.Empty;
        public string TypeAttr { get; set; } = string.Empty;
    }

    public class DocumentUserDto
    {
        public string Email { get; set; } = string.Empty;
        public string Username { get; set; } = string.Empty;
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public string? Role { get; set; } = string.Empty;
        public string UserType { get; set; } = string.Empty;
    
}
namespace DocManagementBackend.Models
{
    public class LignesRequest
    {
        public string Title { get; set; } = string.Empty;
        public string Attribute { get; set; } = string.Empty;
    }

    public class LigneDto
    {
        public int Id { get; set; }
        public int DocumentId { get; set; }
        public string LingeKey { get; set; } = string.Empty;
        public string Title { get; set; } = string.Empty;
        public string Article { get; set; } = string.Empty;
        public float Prix { get; set; }
        public int SousLignesCount { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime UpdatedAt { get; set; }
        public DocumentDto Document { get; set; } = new DocumentDto();
    }

    public class SousLigneDto
    {
        public int Id { get; set; }
        public int LigneId { get; set; }
        public string Title { get; set; } = string.Empty;
        public string Attribute { get; set; } = string.Empty;
        public DateTime CreatedAt { get; set; }
        public DateTime UpdatedAt { get; set; }
        public LigneDto Ligne { get; set; } = new LigneDto();
    }
}namespace DocManagementBackend.Models
{
    public class UserLogDto
    {
        public string Username { get; set; } = string.Empty;
        public string? Role { get; set; } = string.Empty;
    }

    public class LogHistoryDto
    {
        public int Id { get; set; }
        public int ActionType { get; set; }
        public DateTime Timestamp { get; set; }
        public string Description { get; set; } = string.Empty;
        public UserLogDto User { get; set; } = new UserLogDto();
    }
}namespace DocManagementBackend.Models
{
    public class GoogleLoginRequest
    {
        public string IdToken { get; set; } = string.Empty;
    }
}
namespace DocManagementBackend.Models
{
    public class CreateStatusDto
    {
        public string Title { get; set; } = string.Empty;
        public bool IsRequired { get; set; } = true;
        // public bool IsComplete { get; set; } = true;
    }

    public class StatusDto
    {
        public int StatusId { get; set; }
        public string StatusKey { get; set; } = string.Empty;
        public string Title { get; set; } = string.Empty;
        public bool IsRequired { get; set; }
        public bool IsComplete { get; set; }
        public int StepId { get; set; }
    }

    public class DocumentStatusDto
    {
        public int StatusId { get; set; }
        public string Title { get; set; } = string.Empty;
        public bool IsRequired { get; set; }
        public bool IsComplete { get; set; }
        public string? CompletedBy { get; set; }
        public DateTime? CompletedAt { get; set; }
    }

    public class CompleteStatusDto
    {
        public int DocumentId { get; set; }
        public int StatusId { get; set; }
        public bool IsComplete { get; set; } = true;
        public string Comments { get; set; } = string.Empty;
    }

}namespace DocManagementBackend.Models
{
    public class CreateSubTypeDto
    {
        public string Name { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public DateTime StartDate { get; set; }
        public DateTime EndDate { get; set; }
        public int DocumentTypeId { get; set; }
        public bool IsActive { get; set; } = true;
    }

    public class UpdateSubTypeDto
    {
        public string? Name { get; set; }
        public string? Description { get; set; }
        public DateTime? StartDate { get; set; }
        public DateTime? EndDate { get; set; }
        public bool? IsActive { get; set; }
    }

    public class SubTypeDto
    {
        public int Id { get; set; }
        public string SubTypeKey { get; set; } = string.Empty;
        public string Name { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public DateTime StartDate { get; set; }
        public DateTime EndDate { get; set; }
        public int DocumentTypeId { get; set; }
        public bool IsActive { get; set; }
        public DocumentTypeDto? DocumentType { get; set; }
    }
}namespace DocManagementBackend.Models {
    public class UserDto {
        public int Id { get; set; }
        public string Email { get; set; } = string.Empty;
        public string Username { get; set; } = string.Empty;
        // public string PasswordHash { get; set; } = string.Empty;
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public string City { get; set; } = string.Empty;
        public string WebSite { get; set; } = string.Empty;
        public string Address { get; set; } = string.Empty;
        public string PhoneNumber { get; set; } = string.Empty;
        public string Country { get; set; } = string.Empty;
        public string UserType { get; set; } = string.Empty;
        public string Identity { get; set; } = string.Empty;
        public bool IsEmailConfirmed { get; set; } = false;
        public string? EmailVerificationCode { get; set; }
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public bool IsActive { get; set; } = false;
        public bool IsOnline { get; set; } = false;
        // public bool IsBlocked { get; set; } = false;
        // public DateTime? LastLogin { get; set; }
        public string? ProfilePicture { get; set; }
        public RoleDto? Role { get; set; } = new RoleDto();

    }

    public class RoleDto {
        public int RoleId { get; set; }
        public string? RoleName { get; set; } = string.Empty;
    }
}namespace DocManagementBackend.Models
{
    public class AssignCircuitDto
    {
        public int DocumentId { get; set; }
        public int CircuitId { get; set; }
    }

    public class PerformActionDto
    {
        public int DocumentId { get; set; }
        public int ActionId { get; set; }
        public string Comments { get; set; } = string.Empty;
        public bool IsApproved { get; set; } = true;
    }

    public class ReturnToPreviousDto
    {
        public int DocumentId { get; set; }
        public string Comments { get; set; } = string.Empty;
    }

    public class DocumentHistoryDto
    {
        public int Id { get; set; }
        public string StepTitle { get; set; } = string.Empty;
        public string ActionTitle { get; set; } = string.Empty;
        public string StatusTitle { get; set; } = string.Empty;
        public string ProcessedBy { get; set; } = string.Empty;
        public DateTime ProcessedAt { get; set; }
        public string Comments { get; set; } = string.Empty;
        public bool IsApproved { get; set; }
    }

    public class DocumentWorkflowStatusDto
    {
        public int DocumentId { get; set; }
        public string DocumentTitle { get; set; } = string.Empty;
        public int? CircuitId { get; set; }
        public string CircuitTitle { get; set; } = string.Empty;
        public int? CurrentStepId { get; set; }
        public string CurrentStepTitle { get; set; } = string.Empty;
        public int Status { get; set; }
        public string StatusText { get; set; } = string.Empty;
        public bool IsCircuitCompleted { get; set; }
        public List<DocumentStatusDto> Statuses { get; set; } = new();
        public List<ActionDto> AvailableActions { get; set; } = new();
        public bool CanAdvanceToNextStep { get; set; }
        public bool CanReturnToPreviousStep { get; set; }
    }

    public class PendingDocumentDto
    {
        public int DocumentId { get; set; }
        public string DocumentKey { get; set; } = string.Empty;
        public string Title { get; set; } = string.Empty;
        public string CreatedBy { get; set; } = string.Empty;
        public DateTime CreatedAt { get; set; }
        public int CircuitId { get; set; }
        public string CircuitTitle { get; set; } = string.Empty;
        public int CurrentStepId { get; set; }
        public string CurrentStepTitle { get; set; } = string.Empty;
        public int DaysInCurrentStep { get; set; }
    }
    public class MoveNextDto
    {
        public int DocumentId { get; set; }
        public int CurrentStepId { get; set; }
        public int NextStepId { get; set; }
        public string Comments { get; set; } = string.Empty;
    }
    public class MoveToDocumentDto
    {
        public int DocumentId { get; set; }
        public string Comments { get; set; } = string.Empty;
    }

}using DocManagementBackend.Data;
using DocManagementBackend.Models;
using Microsoft.EntityFrameworkCore;

namespace DocManagementBackend.Services
{
    public class CircuitManagementService
    {
        private readonly ApplicationDbContext _context;

        public CircuitManagementService(ApplicationDbContext context)
        {
            _context = context;
        }

        public async Task<Circuit> CreateCircuitAsync(Circuit circuit)
        {
            // Generate circuit key and set defaults
            var counter = await _context.TypeCounter.FirstOrDefaultAsync();
            if (counter == null)
            {
                counter = new TypeCounter { circuitCounter = 1 };
                _context.TypeCounter.Add(counter);
            }
            else
            {
                counter.circuitCounter++;
            }

            string paddedCounter = counter.circuitCounter.ToString("D2");
            circuit.CircuitKey = $"CR{paddedCounter}";
            // circuit.IsActive = true;

            _context.Circuits.Add(circuit);
            await _context.SaveChangesAsync();
            return circuit;
        }

        public async Task<Step> AddStepToCircuitAsync(Step step)
        {
            var circuit = await _context.Circuits
                .Include(c => c.Steps)
                .FirstOrDefaultAsync(c => c.Id == step.CircuitId);

            if (circuit == null)
                throw new KeyNotFoundException($"Circuit ID {step.CircuitId} not found");

            // Generate step key
            // Log the current state
            Console.WriteLine($"Circuit key: {circuit.CircuitKey}");
            Console.WriteLine($"Current step count: {circuit.Steps.Count}");

            // Count existing steps to determine next step number
            int stepCount = circuit.Steps.Count + 1;
            Console.WriteLine($"New step will be number: {stepCount}");

            // Generate the step key with proper incrementing number
            step.StepKey = $"{circuit.CircuitKey}-STEP{stepCount:D2}";
            Console.WriteLine($"Generated step key: {step.StepKey}");

            // If HasOrderedFlow, link to previous step
            if (circuit.HasOrderedFlow && circuit.Steps.Any())
            {
                var previousSteps = circuit.Steps.OrderByDescending(s => s.OrderIndex).ToList();
                var previousStep = previousSteps.FirstOrDefault();

                // Set new step's order index
                step.OrderIndex = (previousStep?.OrderIndex ?? 0) + 1;

                // Update relationships for ordered flow
                if (previousStep != null)
                {
                    // Set this new step's previous step reference
                    step.PrevStepId = previousStep.Id;

                    // Update previous step's next reference
                    // Save first to get an ID for the new step
                    _context.Steps.Add(step);
                    await _context.SaveChangesAsync();

                    var prevStep = await _context.Steps.FindAsync(previousStep.Id);
                    if (prevStep != null)
                    {
                        prevStep.NextStepId = step.Id;
                        _context.Entry(prevStep).State = EntityState.Modified;
                        await _context.SaveChangesAsync();
                    }

                    return step;
                }
            }

            _context.Steps.Add(step);
            await _context.SaveChangesAsync();

            // Verify the step was saved correctly
            var savedStep = await _context.Steps.FindAsync(step.Id);
            Console.WriteLine($"Saved step key: {savedStep!.StepKey}");
            return step;
        }

        public async Task<bool> UpdateStepOrderAsync(int circuitId, List<StepOrderUpdateDto> stepOrders)
        {
            var circuit = await _context.Circuits
                .Include(c => c.Steps)
                .FirstOrDefaultAsync(c => c.Id == circuitId);

            if (circuit == null)
                throw new KeyNotFoundException($"Circuit ID {circuitId} not found");

            // Start a transaction for updating all steps
            using var transaction = await _context.Database.BeginTransactionAsync();

            try
            {
                foreach (var stepOrder in stepOrders)
                {
                    var step = await _context.Steps.FindAsync(stepOrder.StepId);
                    if (step == null || step.CircuitId != circuitId)
                        throw new InvalidOperationException($"Step ID {stepOrder.StepId} not found in circuit {circuitId}");

                    step.OrderIndex = stepOrder.OrderIndex;
                }

                // If circuit has ordered flow, update Next/Prev relationships
                if (circuit.HasOrderedFlow)
                {
                    var orderedSteps = await _context.Steps
                        .Where(s => s.CircuitId == circuitId)
                        .OrderBy(s => s.OrderIndex)
                        .ToListAsync();

                    // Clear existing relationships
                    foreach (var step in orderedSteps)
                    {
                        step.NextStepId = null;
                        step.PrevStepId = null;
                    }

                    // Set new relationships
                    for (int i = 0; i < orderedSteps.Count; i++)
                    {
                        if (i > 0)
                            orderedSteps[i].PrevStepId = orderedSteps[i - 1].Id;

                        if (i < orderedSteps.Count - 1)
                            orderedSteps[i].NextStepId = orderedSteps[i + 1].Id;
                        else
                            orderedSteps[i].IsFinalStep = true; // Last step is final
                    }
                }

                await _context.SaveChangesAsync();
                await transaction.CommitAsync();
                return true;
            }
            catch
            {
                await transaction.RollbackAsync();
                throw;
            }
        }
    }
}using DocManagementBackend.Data;
using DocManagementBackend.Models;
using Microsoft.EntityFrameworkCore;

namespace DocManagementBackend.Services
{
    public class DocumentWorkflowService
    {
        private readonly ApplicationDbContext _context;

        public DocumentWorkflowService(ApplicationDbContext context)
        {
            _context = context;
        }

        public async Task<bool> AssignDocumentToCircuitAsync(int documentId, int circuitId, int userId)
        {
            using var transaction = await _context.Database.BeginTransactionAsync();

            try
            {
                var document = await _context.Documents
                    .Include(d => d.Circuit)
                    .FirstOrDefaultAsync(d => d.Id == documentId);

                if (document == null)
                    throw new KeyNotFoundException($"Document ID {documentId} not found");

                var circuit = await _context.Circuits
                    .Include(c => c.Steps.OrderBy(cd => cd.OrderIndex))
                    .FirstOrDefaultAsync(c => c.Id == circuitId && c.IsActive);

                if (circuit == null || !circuit.Steps.Any())
                    throw new InvalidOperationException($"Circuit ID {circuitId} not found or has no steps");

                var user = await _context.Users.FindAsync(userId);
                if (user == null)
                    throw new KeyNotFoundException($"User ID {userId} not found");

                // Assign document to circuit
                document.CircuitId = circuitId;
                document.Circuit = circuit;
                document.Status = 1; // In Progress

                // Find first step
                var firstStep = circuit.Steps.OrderBy(cd => cd.OrderIndex).First();
                document.CurrentStepId = firstStep.Id;
                document.CurrentStep = firstStep;
                document.IsCircuitCompleted = false;

                // Create history entry
                var historyEntry = new DocumentCircuitHistory
                {
                    DocumentId = documentId,
                    Document = document,
                    StepId = firstStep.Id,
                    Step = firstStep,
                    ProcessedByUserId = userId,
                    ProcessedBy = user,
                    ProcessedAt = DateTime.UtcNow,
                    Comments = "Document assigned to circuit",
                    IsApproved = true
                };
                _context.DocumentCircuitHistory.Add(historyEntry);

                // Initialize document statuses
                var stepStatuses = await _context.Status
                    .Where(s => s.StepId == firstStep.Id)
                    .ToListAsync();

                foreach (var status in stepStatuses)
                {
                    var documentStatus = new DocumentStatus
                    {
                        DocumentId = documentId,
                        StatusId = status.Id,
                        IsComplete = false
                    };
                    _context.DocumentStatus.Add(documentStatus);
                }

                await _context.SaveChangesAsync();
                await transaction.CommitAsync();
                return true;
            }
            catch
            {
                await transaction.RollbackAsync();
                throw;
            }
        }

        public async Task<bool> ProcessActionAsync(int documentId, int actionId, int userId, string comments = "", bool isApproved = true)
        {
            using var transaction = await _context.Database.BeginTransactionAsync();

            try
            {
                var document = await _context.Documents
                    .Include(d => d.Circuit)
                    .Include(d => d.CurrentStep)
                    .FirstOrDefaultAsync(d => d.Id == documentId);

                if (document == null || document.CircuitId == null || document.CurrentStepId == null)
                    throw new InvalidOperationException("Document not assigned to circuit or step");

                var user = await _context.Users
                    .Include(u => u.Role)
                    .FirstOrDefaultAsync(u => u.Id == userId);

                if (user == null)
                    throw new KeyNotFoundException($"User ID {userId} not found");

                var action = await _context.Actions.FindAsync(actionId);
                if (action == null)
                    throw new KeyNotFoundException($"Action ID {actionId} not found");

                // Verify user has permission to perform this action on this step
                var step = document.CurrentStep;
                if (step == null)
                    throw new InvalidOperationException("Current step not found");

                // if (step.ResponsibleRoleId.HasValue && step.ResponsibleRoleId != user.RoleId)
                //     throw new UnauthorizedAccessException("User does not have permission for this step");

                // Verify action is valid for this step
                var stepAction = await _context.StepActions
                    .FirstOrDefaultAsync(sa => sa.StepId == step.Id && sa.ActionId == actionId);

                if (stepAction == null)
                    throw new InvalidOperationException($"Action ID {actionId} not valid for step ID {step.Id}");

                // Find which statuses this action affects
                var affectedStatuses = await _context.ActionStatusEffects
                    .Where(ase => ase.ActionId == actionId && ase.StepId == step.Id)
                    .ToListAsync();

                // Update document statuses
                // foreach (var effect in affectedStatuses)
                // {
                //     var documentStatus = await _context.DocumentStatus
                //         .FirstOrDefaultAsync(ds => ds.DocumentId == documentId && ds.StatusId == effect.StatusId);

                //     if (documentStatus == null)
                //     {
                //         documentStatus = new DocumentStatus
                //         {
                //             DocumentId = documentId,
                //             StatusId = effect.StatusId,
                //             IsComplete = false
                //         };
                //         _context.DocumentStatus.Add(documentStatus);
                //     }

                //     // Set status as complete based on action effect
                //     documentStatus.IsComplete = effect.SetsComplete;
                //     documentStatus.CompletedByUserId = userId;
                //     documentStatus.CompletedAt = DateTime.UtcNow;
                // }

                // Create history entry
                var historyEntry = new DocumentCircuitHistory
                {
                    DocumentId = documentId,
                    StepId = step.Id,
                    ActionId = actionId,
                    ProcessedByUserId = userId,
                    ProcessedAt = DateTime.UtcNow,
                    Comments = comments,
                    IsApproved = isApproved
                };
                _context.DocumentCircuitHistory.Add(historyEntry);

                // Check if action is rejection
                if (!isApproved)
                {
                    document.Status = 3; // Rejected
                    await _context.SaveChangesAsync();
                    await transaction.CommitAsync();
                    return true;
                }

                // Check if all required statuses are complete to advance
                await _context.Entry(step).Collection(s => s.Statuses).LoadAsync();
                var requiredStatuses = step.Statuses.Where(s => s.IsRequired).ToList();

                var allComplete = true;
                foreach (var requiredStatus in requiredStatuses)
                {
                    var docStatus = await _context.DocumentStatus
                        .FirstOrDefaultAsync(ds => ds.DocumentId == documentId && ds.StatusId == requiredStatus.Id);

                    if (docStatus == null || !docStatus.IsComplete)
                    {
                        allComplete = false;
                        break;
                    }
                }

                // If all required statuses complete, advance to next step
                if (allComplete)
                {
                    await AdvanceToNextStepAsync(document, userId, $"All required actions completed by {user.Username}");
                }

                await _context.SaveChangesAsync();
                await transaction.CommitAsync();
                return true;
            }
            catch
            {
                await transaction.RollbackAsync();
                throw;
            }
        }

        public async Task<bool> MoveToNextStepAsync(int documentId, int currentStepId, int nextStepId, int userId, string comments)
        {
            using var transaction = await _context.Database.BeginTransactionAsync();
            try
            {
                var document = await _context.Documents
                    .Include(d => d.Circuit)
                    .Include(d => d.CurrentStep)
                    .FirstOrDefaultAsync(d => d.Id == documentId);

                if (document == null)
                    throw new KeyNotFoundException("Document not found.");

                if (!document.CircuitId.HasValue)
                    throw new InvalidOperationException("Document is not assigned to a circuit.");

                if (document.IsCircuitCompleted)
                    throw new InvalidOperationException("Document workflow is already completed.");

                if (document.CurrentStepId != currentStepId)
                    throw new InvalidOperationException("Current step ID doesn't match the document's current step.");

                // Get the next step
                var nextStep = await _context.Steps.FindAsync(nextStepId);
                if (nextStep == null)
                    throw new KeyNotFoundException("Next step not found.");

                // Verify the next step belongs to the same circuit
                if (nextStep.CircuitId != document.CircuitId)
                    throw new InvalidOperationException("Next step doesn't belong to the document's circuit.");

                // Verify the user is authorized for this action (if the step has role requirements)
                // var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
                // if (user == null)
                //     throw new KeyNotFoundException("User not found.");

                // if (nextStep.ResponsibleRoleId.HasValue && nextStep.ResponsibleRoleId != user.RoleId)
                // {
                //     var requiredRole = await _context.Roles.FindAsync(nextStep.ResponsibleRoleId.Value);
                //     throw new UnauthorizedAccessException($"Only users with role '{requiredRole?.RoleName}' can move documents to this step.");
                // }

                // Check if all required statuses are complete for the current step
                var requiredStatuses = await _context.Status
                    .Where(s => s.StepId == currentStepId && s.IsRequired)
                    .ToListAsync();

                foreach (var status in requiredStatuses)
                {
                    var documentStatus = await _context.DocumentStatus
                        .FirstOrDefaultAsync(ds => ds.DocumentId == documentId && ds.StatusId == status.Id);

                    if (documentStatus == null || !documentStatus.IsComplete)
                        throw new InvalidOperationException($"Required status '{status.Title}' is not complete.{documentStatus!.IsComplete}");
                }

                // Update document to move to next step
                document.CurrentStepId = nextStepId;
                document.CurrentStep = nextStep;
                document.UpdatedAt = DateTime.UtcNow;

                // Mark document as completed if this is the final step
                if (nextStep.IsFinalStep)
                {
                    document.IsCircuitCompleted = true;
                    document.Status = 2; // Completed
                }

                // Create document history record
                var history = new DocumentCircuitHistory
                {
                    DocumentId = documentId,
                    StepId = nextStepId,
                    ProcessedByUserId = userId,
                    ProcessedAt = DateTime.UtcNow,
                    Comments = comments,
                    IsApproved = true
                };

                // Create document statuses for the new step
                var nextStepStatuses = await _context.Status
                    .Where(s => s.StepId == nextStepId)
                    .ToListAsync();

                foreach (var status in nextStepStatuses)
                {
                    var documentStatus = new DocumentStatus
                    {
                        DocumentId = documentId,
                        StatusId = status.Id,
                        IsComplete = false
                    };

                    _context.DocumentStatus.Add(documentStatus);
                }

                _context.DocumentCircuitHistory.Add(history);
                await _context.SaveChangesAsync();
                await transaction.CommitAsync();

                return true;
            }
            catch
            {
                await transaction.RollbackAsync();
                throw;
            }
        }

        public async Task<bool> CompleteDocumentStatusAsync(int documentId, int statusId, int userId, bool isComplete, string comments)
        {
            using var transaction = await _context.Database.BeginTransactionAsync();
            try
            {
                var document = await _context.Documents
                    .Include(d => d.Circuit)
                    .Include(d => d.CurrentStep)
                    .FirstOrDefaultAsync(d => d.Id == documentId);

                if (document == null)
                    throw new KeyNotFoundException("Document not found.");

                if (!document.CircuitId.HasValue)
                    throw new InvalidOperationException("Document is not assigned to a circuit.");

                if (document.IsCircuitCompleted)
                    throw new InvalidOperationException("Document workflow is already completed.");

                if (document.CurrentStepId == null)
                    throw new InvalidOperationException("Document does not have a current step in the workflow.");

                // Get the status
                var status = await _context.Status.FindAsync(statusId);
                if (status == null)
                    throw new KeyNotFoundException("Status not found.");

                // Verify the status belongs to the current step
                if (status.StepId != document.CurrentStepId)
                    throw new InvalidOperationException("The status must belong to the document's current step.");

                // Verify the user has the appropriate role for the current step if required
                // var user = await _context.Users.Include(u => u.Role).FirstOrDefaultAsync(u => u.Id == userId);
                // if (user == null)
                //     throw new KeyNotFoundException("User not found.");

                // if (document.CurrentStep!.ResponsibleRoleId.HasValue &&
                //     document.CurrentStep.ResponsibleRoleId != user.RoleId)
                // {
                //     var requiredRole = await _context.Roles.FindAsync(document.CurrentStep.ResponsibleRoleId.Value);
                //     throw new UnauthorizedAccessException(
                //         $"Only users with role '{requiredRole?.RoleName}' can update statuses in this step.");
                // }

                // Get or create the document status
                var documentStatus = await _context.DocumentStatus
                    .FirstOrDefaultAsync(ds => ds.DocumentId == documentId && ds.StatusId == statusId);

                if (documentStatus == null)
                {
                    documentStatus = new DocumentStatus
                    {
                        DocumentId = documentId,
                        StatusId = statusId,
                        IsComplete = isComplete,
                        CompletedByUserId = isComplete ? userId : null,
                        CompletedAt = isComplete ? DateTime.UtcNow : null
                    };
                    _context.DocumentStatus.Add(documentStatus);
                }
                else
                {
                    documentStatus.IsComplete = isComplete;
                    documentStatus.CompletedByUserId = isComplete ? userId : null;
                    documentStatus.CompletedAt = isComplete ? DateTime.UtcNow : null;
                }

                // Create document history record
                var history = new DocumentCircuitHistory
                {
                    DocumentId = documentId,
                    StepId = document.CurrentStepId.Value,
                    StatusId = statusId,
                    ProcessedByUserId = userId,
                    ProcessedAt = DateTime.UtcNow,
                    // Comments = comments,
                    IsApproved = true
                };

                _context.DocumentCircuitHistory.Add(history);

                // If all required statuses are complete, need to check if we should automatically
                // update the document status
                if (isComplete)
                {
                    // Check if all required statuses are now complete
                    var requiredStatuses = await _context.Status
                        .Where(s => s.StepId == document.CurrentStepId && s.IsRequired)
                        .ToListAsync();

                    bool allComplete = true;

                    foreach (var reqStatus in requiredStatuses)
                    {
                        if (reqStatus.Id == statusId)
                            continue; // We're setting this one complete

                        var docStatus = await _context.DocumentStatus
                            .FirstOrDefaultAsync(ds => ds.DocumentId == documentId && ds.StatusId == reqStatus.Id);

                        if (docStatus == null || !docStatus.IsComplete)
                        {
                            allComplete = false;
                            break;
                        }
                    }

                    // If all required statuses are complete, we can update the document status
                    if (allComplete && requiredStatuses.Count > 0)
                    {
                        // This is just setting a flag that all requirements are met
                        // It does not automatically advance the document to the next step
                        document.Status = 1; // In progress and ready to move
                        document.UpdatedAt = DateTime.UtcNow;
                    }
                }

                await _context.SaveChangesAsync();
                await transaction.CommitAsync();

                return true;
            }
            catch
            {
                await transaction.RollbackAsync();
                throw;
            }
        }

        private async Task AdvanceToNextStepAsync(Document document, int userId, string comments)
        {
            var currentStep = document.CurrentStep;
            if (currentStep == null)
                throw new InvalidOperationException("Current step not found");

            // If final step, complete the circuit
            if (currentStep.IsFinalStep)
            {
                document.IsCircuitCompleted = true;
                document.Status = 2; // Completed

                // Create history entry for completion
                var completionHistory = new DocumentCircuitHistory
                {
                    DocumentId = document.Id,
                    StepId = currentStep.Id,
                    ProcessedByUserId = userId,
                    ProcessedAt = DateTime.UtcNow,
                    Comments = "Circuit completed",
                    IsApproved = true
                };
                _context.DocumentCircuitHistory.Add(completionHistory);

                return;
            }

            // Find next step based on circuit flow
            var circuit = document.Circuit;
            Step? nextStep;

            if (circuit!.HasOrderedFlow && currentStep.NextStepId.HasValue)
            {
                // For ordered flow, use the explicitly defined next step
                nextStep = await _context.Steps.FindAsync(currentStep.NextStepId.Value);
                if (nextStep == null)
                    throw new InvalidOperationException("Next step not found");
            }
            else
            {
                // For unordered flow, find the next appropriate step
                // This implementation would depend on the business rules
                // Here's a simple example that just takes the next by order index
                nextStep = await _context.Steps
                    .Where(s => s.CircuitId == circuit.Id && s.OrderIndex > currentStep.OrderIndex)
                    .OrderBy(s => s.OrderIndex)
                    .FirstOrDefaultAsync();

                if (nextStep == null)
                    throw new InvalidOperationException("No next step found for unordered flow");
            }

            // Update document's current step
            document.CurrentStepId = nextStep.Id;
            document.CurrentStep = nextStep;

            // Create history entry for step transition
            var transitionHistory = new DocumentCircuitHistory
            {
                DocumentId = document.Id,
                StepId = nextStep.Id,
                ProcessedByUserId = userId,
                ProcessedAt = DateTime.UtcNow,
                Comments = comments,
                IsApproved = true
            };
            _context.DocumentCircuitHistory.Add(transitionHistory);

            // Initialize new step's statuses
            var stepStatuses = await _context.Status
                .Where(s => s.StepId == nextStep.Id)
                .ToListAsync();

            foreach (var status in stepStatuses)
            {
                var documentStatus = new DocumentStatus
                {
                    DocumentId = document.Id,
                    StatusId = status.Id,
                    IsComplete = false
                };
                _context.DocumentStatus.Add(documentStatus);
            }
        }

        public async Task<bool> ReturnToPreviousStepAsync(int documentId, int userId, string comments)
        {
            using var transaction = await _context.Database.BeginTransactionAsync();

            try
            {
                var document = await _context.Documents
                    .Include(d => d.Circuit)
                    .Include(d => d.CurrentStep)
                    .FirstOrDefaultAsync(d => d.Id == documentId);

                if (document == null || document.CircuitId == null || document.CurrentStepId == null)
                    throw new InvalidOperationException("Document not assigned to circuit or step");

                var circuit = document.Circuit;
                if (circuit == null || !circuit.AllowBacktrack)
                    throw new InvalidOperationException("Backtracking not allowed for this circuit");

                var currentStep = document.CurrentStep;
                if (currentStep == null || !currentStep.PrevStepId.HasValue)
                    throw new InvalidOperationException("No previous step available");

                var previousStep = await _context.Steps.FindAsync(currentStep.PrevStepId.Value);
                if (previousStep == null)
                    throw new InvalidOperationException("Previous step not found");

                // Clear current step's statuses
                var currentStatuses = await _context.DocumentStatus
                    .Where(ds => ds.DocumentId == documentId &&
                           _context.Status.Any(s => s.Id == ds.StatusId && s.StepId == currentStep.Id))
                    .ToListAsync();

                _context.DocumentStatus.RemoveRange(currentStatuses);

                // Update document's current step
                document.CurrentStepId = previousStep.Id;
                document.CurrentStep = previousStep;

                // Create history entry for backtracking
                var backtrackHistory = new DocumentCircuitHistory
                {
                    DocumentId = document.Id,
                    StepId = previousStep.Id,
                    ProcessedByUserId = userId,
                    ProcessedAt = DateTime.UtcNow,
                    Comments = comments,
                    IsApproved = true
                };
                _context.DocumentCircuitHistory.Add(backtrackHistory);

                // Restore previous step's statuses
                // This might vary based on the requirements - could either:
                // 1. Restore them to their previous state
                // 2. Reset them all to incomplete
                // Here we'll reset them to their previous state
                var previousStatuses = await _context.DocumentCircuitHistory
                    .Where(h => h.DocumentId == documentId && h.StepId == previousStep.Id)
                    .OrderByDescending(h => h.ProcessedAt)
                    .Include(h => h.Status)
                    .ToListAsync();

                foreach (var status in await _context.Status.Where(s => s.StepId == previousStep.Id).ToListAsync())
                {
                    var latestStatus = previousStatuses
                        .FirstOrDefault(h => h.StatusId == status.Id);

                    var documentStatus = new DocumentStatus
                    {
                        DocumentId = document.Id,
                        StatusId = status.Id,
                        IsComplete = latestStatus?.IsApproved ?? false,
                        CompletedByUserId = latestStatus?.ProcessedByUserId,
                        CompletedAt = latestStatus?.ProcessedAt
                    };
                    _context.DocumentStatus.Add(documentStatus);
                }

                await _context.SaveChangesAsync();
                await transaction.CommitAsync();
                return true;
            }
            catch
            {
                await transaction.RollbackAsync();
                throw;
            }
        }

        public async Task<IEnumerable<DocumentCircuitHistory>> GetDocumentCircuitHistory(int documentId)
        {
            return await _context.DocumentCircuitHistory
                .Where(h => h.DocumentId == documentId)
                .Include(h => h.Step)
                .Include(h => h.ProcessedBy)
                .Include(h => h.Action)
                .Include(h => h.Status)
                .OrderByDescending(h => h.ProcessedAt)
                .ToListAsync();
        }
    }
}// using System;
// using System.Collections.Concurrent;
// using System.Text.Json;
// using System.Threading.Tasks;
// using RestSharp;
// using FirebaseAdmin;
// using FirebaseAdmin.Auth;

// namespace DocManagementBackend.Services
// {
//     public class SmsVerificationService
//     {
//         private readonly string _apiKey;
//         private readonly RestClient _client;
//         private static readonly ConcurrentDictionary<string, (string Code, DateTime Expiry)> _verificationCodes = new();

//         public SmsVerificationService(IConfiguration configuration)
//         {
//             _apiKey = configuration["Firebase:WebApiKey"]
//                 ?? throw new InvalidOperationException("Firebase Web API Key is not configured");
//             _client = new RestClient("https://identitytoolkit.googleapis.com/v1");
//         }

//         public async Task<string> SendVerificationCode(string phoneNumber)
//         {
//             try
//             {
//                 // Generate a random 6-digit code
//                 var random = new Random();
//                 var code = random.Next(100000, 999999).ToString();

//                 // Store the code with a 10-minute expiration
//                 _verificationCodes[phoneNumber] = (code, DateTime.UtcNow.AddMinutes(10));

//                 // For debugging
//                 Console.WriteLine($"Generated verification code for {phoneNumber}: {code}");

//                 // In a real implementation, we would use Firebase to send SMS
//                 // For testing, we'll use our own session ID
//                 string sessionId = Guid.NewGuid().ToString();

//                 return sessionId;
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"Error generating verification code: {ex.Message}");
//                 throw new Exception($"Failed to send verification code: {ex.Message}", ex);
//             }
//         }

//         public async Task<bool> VerifyPhoneNumber(string sessionInfo, string code, string phoneNumber)
//         {
//             // For testing, we'll verify against our locally stored codes
//             if (_verificationCodes.TryGetValue(phoneNumber, out var storedData))
//             {
//                 var (storedCode, expiry) = storedData;

//                 // Check if the code matches and hasn't expired
//                 if (storedCode == code && expiry > DateTime.UtcNow)
//                 {
//                     // Remove the code after successful verification
//                     _verificationCodes.TryRemove(phoneNumber, out _);
//                     return true;
//                 }
//             }

//             return false;
//         }

//         // Response classes
//         private class SendVerificationResponse
//         {
//             public string SessionInfo { get; set; } = string.Empty;
//         }

//         private class VerifyPhoneResponse
//         {
//             public string IdToken { get; set; } = string.Empty;
//             public string RefreshToken { get; set; } = string.Empty;
//         }
//     }
// }using System.IdentityModel.Tokens.Jwt;
using System.Net.Mail;
using System.Security.Claims;
using System.Text;
using DocManagementBackend.Models;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.IdentityModel.Tokens;
using DocManagementBackend.Data;
// using DocManagementBackend.Models;

namespace DocManagementBackend.Utils
{
    public static class AuthHelper
    {
        // private readonly ApplicationDbContext _context;
        // private readonly IConfiguration _config;
        // public AuthController(ApplicationDbContext context, IConfiguration config)
        // {
        //     _context = context; _config = config;
        // }
        // Password validation logic
        public static bool IsValidPassword(string password)
        {
            return password.Length >= 8 && password.Any(char.IsLower) &&
                   password.Any(char.IsUpper) && password.Any(char.IsDigit) &&
                   password.Any(ch => !char.IsLetterOrDigit(ch));
        }
        public static void SendEmail(string to, string subject, string body)
        {
            try
            {
                string? emailAddress = Environment.GetEnvironmentVariable("EMAIL_ADDRESS");
                string? emailPassword = Environment.GetEnvironmentVariable("EMAIL_PASSWORD");
                if (string.IsNullOrEmpty(emailAddress) || string.IsNullOrEmpty(emailPassword))
                    throw new InvalidOperationException("Email address or password is not set in environment variables.");
                using (var smtp = new SmtpClient("smtp.gmail.com", 587))
                {
                    smtp.Credentials = new System.Net.NetworkCredential(emailAddress, emailPassword);
                    smtp.EnableSsl = true;
                    var message = new MailMessage();
                    message.To.Add(to); message.Subject = subject;
                    message.Body = body; message.IsBodyHtml = true;
                    message.From = new MailAddress(emailAddress);
                    smtp.Send(message);
                }
            }
            catch (Exception ex) { Console.WriteLine($"Email send failed: {ex.Message}"); }
        }

        public static string GenerateAccessToken(User user)
        {
            // var jwtSettings = _config.GetSection("JwtSettings");
            var secretKey = Environment.GetEnvironmentVariable("JWT_SECRET"); ;
            if (string.IsNullOrEmpty(secretKey))
                throw new InvalidOperationException("JWT configuration is missing.");
            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey));
            var claims = new[] {new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
                new Claim(JwtRegisteredClaimNames.Email, user.Email),
                new Claim("Username", user.Username),
                new Claim("IsActive", user.IsActive.ToString()),
                new Claim(ClaimTypes.Role, user.Role?.RoleName ?? "SimpleUser")};
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
            var expMinutes = 180;
            // if (string.IsNullOrEmpty(expMinutes))
            //     throw new InvalidOperationException("ExpiryMinutes is missing.");
            var token = new JwtSecurityToken(issuer: Environment.GetEnvironmentVariable("ISSUER"),
                audience: Environment.GetEnvironmentVariable("AUDIENCE"), claims: claims,
                expires: DateTime.UtcNow.AddMinutes(expMinutes),
                signingCredentials: creds);

            return new JwtSecurityTokenHandler().WriteToken(token);
        }
        public static string GenerateRefreshToken()
        {
            return Convert.ToBase64String(Guid.NewGuid().ToByteArray());
        }
        public static string CreateEmailBody(string verificationLink, string verificationCode)
        {
            return $@"
                <html><head><style>
                        body {{font-family: Arial, sans-serif; line-height: 1.6; color: #fff; width: 100vw; height: 80vh; align-items: center;
                            background-color: #333333; margin: 0; padding: 0; display: flex; justify-content: center; color:white;}}
                        h2 {{font-size: 24px; color: #c3c3c7;}}
                        p {{color: #c3c3c7; margin: 0 0 20px;}}
                        .button {{display: inline-block; padding: 10px 20px; margin: 20px 0; font-size: 16px;
                            color: #fff; background-color: #007bff; text-decoration: none; border-radius: 5px;}}
                        .button:hover {{background-color: rgb(6, 75, 214);}}
                        .footer {{margin-top: 20px; font-size: 12px; color: #f8f6f6;}}
                        span {{display: inline-block; font-size: 1rem; font-weight: bold; color: #2d89ff;
                            background: #f0f6ff; padding: 10px 10px; border-radius: 8px; letter-spacing: 3px;
                            font-family: monospace; border: 2px solid #ffffff; margin: 5px;}}
                        .card {{padding: 20px; background-color: #555555; margin: auto; border-radius: 12px;
                            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); color: #c3c3c7;}}
                    </style></head>
                <body><div class='card'>
                        <h2>Email Verification</h2>
                        <p>Thank you for registering with us! To complete your registration, please
                            verify your email address, your verification code is
                            <br /><span>{verificationCode}</span> <br />
                            by clicking the button below you will be redirected to the verification
                            page:</p>
                        <a href='{verificationLink}' class='button'>Verify Email</a>
                        <p>If the button doesn't work, you can also copy and paste the following
                            link into your browser:</p>
                        <p><a href='{verificationLink}'>{verificationLink}</a></p>
                        <div class='footer'><p>If you did not request this verification, please ignore this email.</p>
                        </div></div></body></html>";
        }
        public static string createPassEmailBody(string verificationLink)
        {
            return $@"
                <html><head><style>
                        body {{font-family: Arial, sans-serif; line-height: 1.6;
                            color: #fff; width: 100vw; height: 80vh; background-color: #333333; margin: 0; padding: 0;
                            display: flex; justify-content: center; align-items: center;}}
                        h2 {{font-size: 24px; color: #c3c3c7;}}
                        p {{margin: 0 0 20px;}}
                        .button {{display: inline-block; padding: 10px 20px; margin: 20px 0; font-size: 16px; color: #fff;
                            background-color: #007bff; text-decoration: none; border-radius: 5px;}}
                        .button:hover {{background-color: rgb(6, 75, 214);}}
                        .footer {{margin-top: 20px; font-size: 12px; color: #f8f6f6;}}
                        span {{display: inline-block; font-size: 1.5rem; font-weight: bold; color: #2d89ff; background: #f0f6ff;
                            padding: 10px 15px; border-radius: 8px; letter-spacing: 3px; font-family: monospace; border: 2px solid #ffffff; margin: 5px;}}
                        .card {{padding: 20px; width: 50%; background-color: #555555; margin: auto;
                            border-radius: 12px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);}}
                    </style></head>
                <body><div class='card'><h2>Reset Password</h2>
                        <p>To reset your password click on the button bellow:</p>
                        <a href='{verificationLink}' class='button'>Reset Password</a>
                        <p>If the button doesn't work, you can also copy and paste the following
                            link into your browser:</p>
                        <p><a href='{verificationLink}'>{verificationLink}</a></p>
                        <div class='footer'><p>If you did not request this verification, please ignore this email.</p>
                        </div></div></body></html>";
        }
    }
}using System;
using System.Linq;
using System.Security.Cryptography;

 namespace DocManagementBackend.utils
{
    public class PasswordGenerator
    {
        private static readonly RandomNumberGenerator Rng = RandomNumberGenerator.Create();

        private static readonly char[] LowercaseLetters = "abcdefghijklmnopqrstuvwxyz".ToCharArray();
        private static readonly char[] UppercaseLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".ToCharArray();
        private static readonly char[] Digits = "0123456789".ToCharArray();
        private static readonly char[] SpecialCharacters = "!@#$%^&*()-_=+[]{}|;:,.<>/?".ToCharArray();

        public static string GenerateRandomPassword(int length = 12)
        {
            if (length < 8)
                throw new ArgumentException("Password length must be at least 8 characters.");

            var passwordChars = new char[length];
            passwordChars[0] = GetRandomChar(LowercaseLetters);
            passwordChars[1] = GetRandomChar(UppercaseLetters);
            passwordChars[2] = GetRandomChar(Digits);
            passwordChars[3] = GetRandomChar(SpecialCharacters);

            var allCharacters = LowercaseLetters
                .Concat(UppercaseLetters)
                .Concat(Digits)
                .Concat(SpecialCharacters)
                .ToArray();

            for (int i = 4; i < length; i++)
                passwordChars[i] = GetRandomChar(allCharacters);

            Shuffle(passwordChars);

            return new string(passwordChars);
        }

        private static char GetRandomChar(char[] characters) {
            byte[] randomNumber = new byte[1];
            Rng.GetBytes(randomNumber);
            return characters[randomNumber[0] % characters.Length];
        }

        private static void Shuffle(char[] array) {
            int n = array.Length;
            while (n > 1)
            {
                byte[] randomNumber = new byte[1];
                Rng.GetBytes(randomNumber);
                int k = randomNumber[0] % n;
                n--;
                char value = array[k];
                array[k] = array[n];
                array[n] = value;
            }
        }
    }
}using System;
using System.Linq.Expressions;
using DocManagementBackend.Models;


namespace DocManagementBackend.Mappings
{
    public static class LigneMappings
    {
        public static Expression<Func<Ligne, LigneDto>> ToLigneDto = l => new LigneDto
        {
            Id = l.Id,
            DocumentId = l.DocumentId,
            LingeKey = l.LigneKey,
            Title = l.Title,
            Article = l.Article,
            Prix = l.Prix,
            CreatedAt = l.CreatedAt,
            UpdatedAt = l.UpdatedAt,
            Document = new DocumentDto
            {
                Id = l.Document!.Id,
                DocumentKey = l.Document.DocumentKey,
                DocumentAlias = l.Document.DocumentAlias,
                Title = l.Document.Title,
                Content = l.Document.Content,
                TypeId = l.Document.TypeId,
                DocumentType = l.Document.DocumentType == null
                    ? null
                    : new DocumentTypeDto
                    {
                        TypeKey = l.Document.DocumentType.TypeKey,
                        TypeName = l.Document.DocumentType.TypeName,
                        TypeAttr = l.Document.DocumentType.TypeAttr
                    },
                CreatedAt = l.Document.CreatedAt,
                UpdatedAt = l.Document.UpdatedAt,
                Status = l.Document.Status,
                CreatedByUserId = l.Document.CreatedByUserId,
                CreatedBy = l.Document.CreatedBy == null
                    ? null
                    : new DocumentUserDto
                    {
                        Email = l.Document.CreatedBy.Email,
                        Username = l.Document.CreatedBy.Username,
                        FirstName = l.Document.CreatedBy.FirstName,
                        LastName = l.Document.CreatedBy.LastName,
                        UserType = l.Document.CreatedBy.UserType,
                        Role = l.Document.CreatedBy.Role != null
                            ? l.Document.CreatedBy.Role.RoleName
                            : "SimpleUser"
                    },
                LignesCount = l.Document.Lignes.Count,
                SousLignesCount = l.Document.Lignes.Sum(ll => ll.SousLignes.Count)
            },
            SousLignesCount = l.SousLignes.Count
        };

    }

    public static class SousLigneMappings
    {
        public static Expression<Func<SousLigne, SousLigneDto>> ToSousLigneDto = s => new SousLigneDto
        {
            Id = s.Id,
            LigneId = s.LigneId,
            Title = s.Title,
            Attribute = s.Attribute,
            Ligne = new LigneDto
            {
                Id = s.Id,
                DocumentId = s.Ligne!.DocumentId,
                LingeKey = s.Ligne.LigneKey,
                Title = s.Ligne.Title,
                Article = s.Ligne.Article,
                Prix = s.Ligne.Prix,
                CreatedAt = s.Ligne.CreatedAt,
                UpdatedAt = s.Ligne.UpdatedAt,
                Document = new DocumentDto
                {
                    Id = s.Ligne.Document!.Id,
                    DocumentKey = s.Ligne.Document.DocumentKey,
                    DocumentAlias = s.Ligne.Document.DocumentAlias,
                    Title = s.Ligne.Document.Title,
                    Content = s.Ligne.Document.Content,
                    TypeId = s.Ligne.Document.TypeId,
                    DocumentType = s.Ligne.Document.DocumentType == null
                        ? null
                        : new DocumentTypeDto
                        {
                            TypeKey = s.Ligne.Document.DocumentType.TypeKey,
                            TypeName = s.Ligne.Document.DocumentType.TypeName,
                            TypeAttr = s.Ligne.Document.DocumentType.TypeAttr
                        },
                    CreatedAt = s.Ligne.Document.CreatedAt,
                    UpdatedAt = s.Ligne.Document.UpdatedAt,
                    Status = s.Ligne.Document.Status,
                    CreatedByUserId = s.Ligne.Document.CreatedByUserId,
                    CreatedBy = s.Ligne.Document.CreatedBy == null
                        ? null
                        : new DocumentUserDto
                        {
                            Email = s.Ligne.Document.CreatedBy.Email,
                            Username = s.Ligne.Document.CreatedBy.Username,
                            FirstName = s.Ligne.Document.CreatedBy.FirstName,
                            LastName = s.Ligne.Document.CreatedBy.LastName,
                            UserType = s.Ligne.Document.CreatedBy.UserType,
                            Role = s.Ligne.Document.CreatedBy.Role != null
                                ? s.Ligne.Document.CreatedBy.Role.RoleName
                                : "SimpleUser"
                        }
                }
            }
        };
    }

    public static class DocumentMappings
    {
        public static Expression<Func<Document, DocumentDto>> ToDocumentDto = d => new DocumentDto
        {
            Id = d.Id,
            DocumentKey = d.DocumentKey,
            DocumentAlias = d.DocumentAlias,
            Title = d.Title,
            Content = d.Content,
            CreatedAt = d.CreatedAt,
            UpdatedAt = d.UpdatedAt,
            DocDate = d.DocDate,
            Status = d.Status,
            TypeId = d.TypeId,
            DocumentType = new DocumentTypeDto
            {
                TypeKey = d.DocumentType!.TypeKey,
                TypeName = d.DocumentType!.TypeName,
                TypeAttr = d.DocumentType.TypeAttr
            },
            SubTypeId = d.SubTypeId,
            SubType = d.SubType == null ? null : new SubTypeDto
            {
                Id = d.SubType.Id,
                SubTypeKey = d.SubType.SubTypeKey,
                Name = d.SubType.Name,
                Description = d.SubType.Description,
                StartDate = d.SubType.StartDate,
                EndDate = d.SubType.EndDate,
                DocumentTypeId = d.SubType.DocumentTypeId,
                IsActive = d.SubType.IsActive
            },
            CreatedByUserId = d.CreatedByUserId,
            CreatedBy = new DocumentUserDto
            {
                Email = d.CreatedBy.Email,
                Username = d.CreatedBy.Username,
                FirstName = d.CreatedBy.FirstName,
                LastName = d.CreatedBy.LastName,
                UserType = d.CreatedBy.UserType,
                Role = d.CreatedBy.Role != null ? d.CreatedBy.Role.RoleName : string.Empty
            },
            LignesCount = d.Lignes.Count,
            SousLignesCount = d.Lignes.Sum(l => l.SousLignes.Count),
            CircuitId = d.CircuitId,
            CurrentStepId = d.CurrentStepId,
            CurrentStepTitle = d.CurrentStep != null ? d.CurrentStep.Title : string.Empty,
            IsCircuitCompleted = d.IsCircuitCompleted
        };
    }

    public static class UserMappings
    {
        public static Expression<Func<User, UserDto>> ToUserDto = d => new UserDto
        {
            Id = d.Id,
            Email = d.Email,
            Username = d.Username,
            FirstName = d.FirstName,
            LastName = d.LastName,
            City = d.City,
            WebSite = d.WebSite,
            Address = d.Address,
            PhoneNumber = d.PhoneNumber,
            Country = d.Country,
            UserType = d.UserType,
            Identity = d.Identity,
            IsEmailConfirmed = d.IsEmailConfirmed,
            EmailVerificationCode = d.EmailVerificationCode,
            IsActive = d.IsActive,
            IsOnline = d.IsOnline,
            ProfilePicture = d.ProfilePicture,
            Role = new RoleDto
            {
                RoleId = d.Role!.Id,
                RoleName = d.Role.RoleName
            }
        };
    }
}